import { Bezier } from 'bezier-js';

/**
 * A vector with three components, $\begin{pmatrix} x \\ y \\ z \end{pmatrix}$.
 * Can also be used to represent a two-component vector.
 *
 * A `Vec3` is immutable.
 *
 * @example
 *
 * ```ts,runnable,console
 * import { Vec3 } from '~/math/lib';
 *
 * console.log('Vector addition:', Vec3.of(1, 2, 3).plus(Vec3.of(0, 1, 0)));
 * console.log('Scalar multiplication:', Vec3.of(1, 2, 3).times(2));
 * console.log('Cross products:', Vec3.unitX.cross(Vec3.unitY));
 * console.log('Magnitude:', Vec3.of(1, 2, 3).length(), 'or', Vec3.of(1, 2, 3).magnitude());
 * console.log('Square Magnitude:', Vec3.of(1, 2, 3).magnitudeSquared());
 * console.log('As an array:', Vec3.unitZ.asArray());
 * ```
 */
interface IVec3 {
    readonly x: number;
    readonly y: number;
    readonly z: number;
    /**
       * Returns the x, y components of this.
       * May be implemented as a getter method.
       */
    readonly xy: {
        x: number;
        y: number;
    };
    /** Returns the vector's `idx`th component. For example, `Vec3.of(1, 2, 3).at(1) → 2`. */
    at(i: number): number;
    /** Alias for `.magnitude`. */
    length(): number;
    /** Returns the length of this vector in ℝ^3. */
    magnitude(): number;
    magnitudeSquared(): number;
    /**
       * Interpreting this vector as a point in ℝ^3, computes the square distance
       * to another point, `p`.
       *
       * Equivalent to `.minus(p).magnitudeSquared()`.
       */
    squareDistanceTo(other: IVec3): number;
    /**
       * Interpreting this vector as a point in ℝ³, returns the distance to the point
       * `p`.
       *
       * Equivalent to `.minus(p).magnitude()`.
       */
    distanceTo(p: IVec3): number;
    /**
       * Returns the entry of this with the greatest magnitude.
       *
       * In other words, returns $\max \{ |x| : x \in {\bf v} \}$, where ${\bf v}$ is the set of
       * all entries of this vector.
       *
       * **Example**:
       * ```ts,runnable,console
       * import { Vec3 } from '~/math/lib';
       * console.log(Vec3.of(-1, -10, 8).maximumEntryMagnitude()); // -> 10
       * ```
       */
    maximumEntryMagnitude(): number;
    /**
       * Return this' angle in the XY plane (treats this as a Vec2).
       *
       * This is equivalent to `Math.atan2(vec.y, vec.x)`.
       *
       * As such, observing that `Math.atan2(-0, -1)` $\approx -\pi$ and `Math.atan2(0, -1)` $\approx \pi$
       * the resultant angle is in the range $[-\pi, \pi]$.
       *
       * **Example**:
       * ```ts,runnable,console
       * import { Vec2 } from '~/math/lib';
       * console.log(Vec2.of(-1, -0).angle()); // atan2(-0, -1)
       * console.log(Vec2.of(-1, 0).angle());  // atan2(0, -1)
       * ```
       */
    angle(): number;
    /**
       * Returns a unit vector in the same direction as this.
       *
       * If `this` has zero length, the resultant vector has `NaN` components.
       */
    normalized(): IVec3;
    /**
       * Like {@link normalized}, except returns zero if this has zero magnitude.
       */
    normalizedOrZero(): IVec3;
    /** @returns A copy of `this` multiplied by a scalar. */
    times(c: number): IVec3;
    /** Performs vector addition. */
    plus(v: IVec3): IVec3;
    minus(v: IVec3): IVec3;
    /**
       * Computes the scalar product between this and `v`.
       *
       * In particular, `a.dot(b)` is equivalent to `a.x * b.x + a.y * b.y + a.z * b.z`.
       */
    dot(v: IVec3): number;
    /** Computes the cross product between this and `v` */
    cross(v: IVec3): IVec3;
    /**
       * If `other` is a `Vec3`, multiplies `this` component-wise by `other`. Otherwise,
       * if `other is a `number`, returns the result of scalar multiplication.
       *
       * @example
       * ```
       * Vec3.of(1, 2, 3).scale(Vec3.of(2, 4, 6)); // → Vec3(2, 8, 18)
       * ```
       */
    scale(other: IVec3 | number): IVec3;
    /**
       * Returns a vector orthogonal to this. If this is a Vec2, returns `this` rotated
       * 90 degrees counter-clockwise.
       */
    orthog(): IVec3;
    /** Returns this plus a vector of length `distance` in `direction`. */
    extend(distance: number, direction: IVec3): IVec3;
    /** Returns a vector `fractionTo` of the way to target from this. */
    lerp(target: IVec3, fractionTo: number): IVec3;
    /**
       * `zip` Maps a component of this and a corresponding component of
       * `other` to a component of the output vector.
       *
       * @example
       * ```
       * const a = Vec3.of(1, 2, 3);
       * const b = Vec3.of(0.5, 2.1, 2.9);
       *
       * const zipped = a.zip(b, (aComponent, bComponent) => {
       *   return Math.min(aComponent, bComponent);
       * });
       *
       * console.log(zipped.toString()); // → Vec(0.5, 2, 2.9)
       * ```
       */
    zip(other: IVec3, zip: (componentInThis: number, componentInOther: number) => number): IVec3;
    /**
       * Returns a vector with each component acted on by `fn`.
       *
       * @example
       * ```ts,runnable,console
       * import { Vec3 } from '~/math/lib';
       * console.log(Vec3.of(1, 2, 3).map(val => val + 1)); // → Vec(2, 3, 4)
       * ```
       */
    map(fn: (component: number, index: number) => number): IVec3;
    asArray(): [number, number, number];
    /**
       * @param tolerance The maximum difference between two components for this and [other]
       * to be considered equal.
       *
       * @example
       * ```
       * Vec3.of(1, 2, 3).eq(Vec3.of(4, 5, 6), 100);  // → true
       * Vec3.of(1, 2, 3).eq(Vec3.of(4, 5, 6), 0.1);  // → false
       * Vec3.of(1, 2, 3).eq(Vec3.of(4, 5, 6), 3);    // → true
       * Vec3.of(1, 2, 3).eq(Vec3.of(4, 5, 6), 3.01); // → true
       * Vec3.of(1, 2, 3).eq(Vec3.of(4, 5, 6), 2.99); // → false
       * ```
       */
    eq(other: IVec3, tolerance?: number): boolean;
    toString(): string;
}
interface IVec2 extends IVec3 {
    readonly z: number;
}
declare class Vec2Impl implements IVec3 {
    readonly x: number;
    readonly y: number;
    constructor(x: number, y: number);
    get z(): number;
    get xy(): {
        x: number;
        y: number;
    };
    at(idx: number): number;
    length(): number;
    magnitude(): number;
    magnitudeSquared(): number;
    squareDistanceTo(p: IVec3): number;
    distanceTo(p: IVec3): number;
    maximumEntryMagnitude(): number;
    angle(): number;
    normalized(): IVec3;
    normalizedOrZero(): IVec3;
    times(c: number): IVec3;
    plus(v: IVec3): IVec3;
    minus(v: IVec3): IVec3;
    dot(other: IVec3): number;
    cross(other: IVec3): IVec3;
    scale(other: IVec3 | number): IVec3;
    orthog(): IVec3;
    extend(distance: number, direction: IVec3): IVec3;
    lerp(target: IVec3, fractionTo: number): IVec3;
    zip(other: IVec3, zip: (componentInThis: number, componentInOther: number) => number): IVec3;
    map(fn: (component: number, index: number) => number): IVec3;
    asArray(): [number, number, number];
    eq(other: IVec3, fuzz?: number): boolean;
    toString(): string;
}
/**
 * A `Vec2` is a {@link Vec3} optimized for working in a plane. `Vec2`s have an
 * always-zero `z` component.
 *
 * ```ts,runnable,console
 * import { Vec2 } from '~/math/lib';
 *
 * const v = Vec2.of(1, 2);
 * console.log('a Vec2:', v);
 * console.log('x component:', v.x);
 * console.log('z component:', v.z);
 * ```
 */
declare namespace Vec2 {
    /**
       * Creates a `Vec2` from an x and y coordinate.
       *
       * @example
       * ```ts,runnable,console
       * import { Vec2 } from '~/math/lib';
       * const v = Vec2.of(3, 4); // x=3, y=4.
       * ```
       */
    function of(x: number, y: number): Vec2Impl;
    /**
       * Creates a `Vec2` from an object containing `x` and `y` coordinates.
       *
       * @example
       * ```ts,runnable,console
       * import { Vec2 } from '~/math/lib';
       * const v1 = Vec2.ofXY({ x: 3, y: 4.5 });
       * const v2 = Vec2.ofXY({ x: -123.4, y: 1 });
       * ```
       */
    function ofXY({ x, y }: {
        x: number;
        y: number;
    }): Vec2Impl;
    /** A vector of length 1 in the X direction (→). */
    const unitX: Vec2Impl;
    /** A vector of length 1 in the Y direction (↑). */
    const unitY: Vec2Impl;
    /** The zero vector: A vector with x=0, y=0. */
    const zero: Vec2Impl;
}
declare namespace Vec3 {
    /**
       * Construct a vector from three components.
       *
       * @example
       * ```ts,runnable,console
       * import { Vec3 } from '~/math/lib';
       * const v1 = Vec3.of(1, 2, 3);
       * console.log(v1.plus(Vec3.of(0, 100, 0)));
       * ```
       */
    function of(x: number, y: number, z: number): IVec3;
    /** A unit vector in the x direction (`[1, 0, 0]`). */
    const unitX: Vec2Impl;
    /** A unit vector in the y direction (`[0, 1, 0]`). */
    const unitY: Vec2Impl;
    /** The zero vector (`[0, 0, 0]`). */
    const zero: Vec2Impl;
    /** A vector of length 1 in the z direction. */
    const unitZ: IVec3;
}

/**
 * See {@link Mat33.toArray}.
 */
type Mat33Array = [number, number, number, number, number, number, number, number, number];
/**
 * Represents a three dimensional linear transformation or
 * a two-dimensional affine transformation. (An affine transformation scales/rotates/shears
 * **and** translates while a linear transformation just scales/rotates/shears).
 *
 * In addition to other matrices, {@link Mat33}s can be used to transform {@link Vec3}s and {@link Vec2}s.
 *
 * For example, to move the point $(1, 1)$ by 5 units to the left and 6 units up,
 * ```ts,runnable,console
 * import {Mat33, Vec2} from '~/math/lib';
 *
 * const moveLeftAndUp = Mat33.translation(Vec2.of(5, 6));
 * console.log(moveLeftAndUp);
 * ```
 *
 * This `moveLeftAndUp` matrix could then translate (move) a {@link Vec2} using
 * {@link Mat33.transformVec2}:
 *
 * ```ts,runnable,console
 * ---use-previous---
 * ---visible---
 * console.log(moveLeftAndUp.transformVec2(Vec2.of(1, 1)));
 * console.log(moveLeftAndUp.transformVec2(Vec2.of(-1, 2)));
 * ```
 *
 * It's also possible to create transformation matrices that scale and rotate.
 * A single transform matrix can be created from multiple using matrix multiplication
 * (see {@link Mat33.rightMul}):
 *
 * ```ts,runnable,console
 * ---use-previous---
 * ---visible---
 * // Create a matrix by right multiplying.
 * const scaleThenRotate =
 *   // The resultant matrix first scales by a factor of two
 *   Mat33.scaling2D(2).rightMul(
 *     // ...then rotates by pi/2 radians = 90 degrees.
 *     Mat33.zRotation(Math.PI / 2)
 *   );
 * console.log(scaleThenRotate);
 *
 * // Use scaleThenRotate to scale then rotate a vector.
 * console.log(scaleThenRotate.transformVec2(Vec2.unitX));
 * ```
 */
declare class Mat33 {
    readonly a1: number;
    readonly a2: number;
    readonly a3: number;
    readonly b1: number;
    readonly b2: number;
    readonly b3: number;
    readonly c1: number;
    readonly c2: number;
    readonly c3: number;
    private readonly rows;
    /**
       * Creates a matrix from inputs in the form,
       * $$
       * \begin{bmatrix}
       *   a1 & a2 & a3 \\
       *   b1 & b2 & b3 \\
       *   c1 & c2 & c3
       * \end{bmatrix}
       * $$
       *
       * Static constructor methods are also available.
       * See {@link Mat33.scaling2D}, {@link Mat33.zRotation}, {@link Mat33.translation}, and {@link Mat33.fromCSSMatrix}.
       */
    constructor(a1: number, a2: number, a3: number, b1: number, b2: number, b3: number, c1: number, c2: number, c3: number);
    /**
       * Creates a matrix from the given rows:
       * $$
       * \begin{bmatrix}
       *  \texttt{r1.x} & \texttt{r1.y} & \texttt{r1.z}\\
       *  \texttt{r2.x} & \texttt{r2.y} & \texttt{r2.z}\\
       *  \texttt{r3.x} & \texttt{r3.y} & \texttt{r3.z}\\
       * \end{bmatrix}
       * $$
       */
    static ofRows(r1: IVec3, r2: IVec3, r3: IVec3): Mat33;
    /** The 3x3 [identity matrix](https://en.wikipedia.org/wiki/Identity_matrix). */
    static identity: Mat33;
    /**
       * Either returns the inverse of this, or, if this matrix is singular/uninvertable,
       * returns Mat33.identity.
       *
       * This may cache the computed inverse and return the cached version instead of recomputing
       * it.
       */
    inverse(): Mat33;
    invertable(): boolean;
    private cachedInverse;
    private computeInverse;
    transposed(): Mat33;
    /**
       * [Right-multiplies](https://en.wikipedia.org/wiki/Matrix_multiplication) this by `other`.
       *
       * See also {@link transformVec3} and {@link transformVec2}.
       *
       * Example:
       * ```ts,runnable,console
       * import {Mat33, Vec2} from '~/math/lib';
       * console.log(Mat33.identity.rightMul(Mat33.identity));
       *
       * // Create a matrix by right multiplying.
       * const scaleThenRotate =
       *   // The resultant matrix first scales by a factor of two
       *   Mat33.scaling2D(2).rightMul(
       *     // ...then rotates by pi/4 radians = 45 degrees.
       *     Mat33.zRotation(Math.PI / 4)
       *   );
       * console.log(scaleThenRotate);
       *
       * // Use scaleThenRotate to scale then rotate a vector.
       * console.log(scaleThenRotate.transformVec2(Vec2.unitX));
       * ```
       */
    rightMul(other: Mat33): Mat33;
    /**
       * Applies this as an **affine** transformation to the given vector.
       * Returns a transformed version of `other`.
       *
       * Unlike {@link transformVec3}, this **does** translate the given vector.
       */
    transformVec2(other: IVec2): IVec2;
    /**
       * Applies this as a linear transformation to the given vector (doesn't translate).
       * This is the standard way of transforming vectors in ℝ³.
       */
    transformVec3(other: IVec3): IVec3;
    /** @returns true iff this is the identity matrix. */
    isIdentity(): boolean;
    /** Returns true iff this = other ± fuzz */
    eq(other: Mat33, fuzz?: number): boolean;
    /**
       * Creates a human-readable representation of the matrix.
       *
       * Example:
       * ```ts,runnable,console
       * import { Mat33 } from '~/math/lib';
       * console.log(Mat33.identity.toString());
       * ```
       */
    toString(): string;
    /**
       * ```
       * result[0] = top left element
       * result[1] = element at row zero, column 1
       * ...
       * ```
       *
       * Example:
       * ```ts,runnable,console
       * import { Mat33 } from '~/math/lib';
       * console.log(
       *   new Mat33(
       *     1, 2, 3,
       *     4, 5, 6,
       *     7, 8, 9,
       *   )
       * );
       * ```
       */
    toArray(): Mat33Array;
    /**
       * Returns a new `Mat33` where each entry is the output of the function
       * `mapping`.
       *
       * @example
       * ```
       * new Mat33(
       *  1, 2, 3,
       *  4, 5, 6,
       *  7, 8, 9,
       * ).mapEntries(component => component - 1);
       * // → ⎡ 0, 1, 2 ⎤
       * //   ⎢ 3, 4, 5 ⎥
       * //   ⎣ 6, 7, 8 ⎦
       * ```
       */
    mapEntries(mapping: (component: number, rowcol: [number, number]) => number): Mat33;
    /** Estimate the scale factor of this matrix (based on the first row). */
    getScaleFactor(): number;
    /** Returns the `idx`-th column (`idx` is 0-indexed). */
    getColumn(idx: number): IVec3;
    /** Returns the magnitude of the entry with the largest entry */
    maximumEntryMagnitude(): number;
    /**
       * Constructs a 3x3 translation matrix (for translating `Vec2`s) using
       * **transformVec2**.
       *
       * Creates a matrix in the form
       * $$
       * 	\begin{pmatrix}
       * 		1 & 0 & {\tt amount.x}\\
       * 		0 & 1 & {\tt amount.y}\\
       * 		0 & 0 & 1
       * 	\end{pmatrix}
       * $$
       */
    static translation(amount: IVec2): Mat33;
    /**
       * Creates a matrix for rotating `Vec2`s about `center` by some number of `radians`.
       *
       * For this function, {@link Vec2}s are considered to be points in 2D space.
       *
       * For example,
       * ```ts,runnable,console
       * import { Mat33, Vec2 } from '~/math/lib';
       *
       * const halfCircle = Math.PI; // PI radians = 180 degrees = 1/2 circle
       * const center = Vec2.of(1, 1); // The point (1,1)
       * const rotationMatrix = Mat33.zRotation(halfCircle, center);
       *
       * console.log(
       *   'Rotating (0,0) 180deg about', center, 'results in',
       *   // Rotates (0,0)
       *   rotationMatrix.transformVec2(Vec2.zero),
       * );
       * ```
       */
    static zRotation(radians: number, center?: IVec2): Mat33;
    static scaling2D(amount: number | IVec2, center?: IVec2): Mat33;
    /**
       * **Note**: Assumes `this.c1 = this.c2 = 0` and `this.c3 = 1`.
       *
       * @see {@link fromCSSMatrix}
       */
    toCSSMatrix(): string;
    /**
       * Converts a CSS-form `matrix(a, b, c, d, e, f)` to a Mat33.
       *
       * Note that such a matrix has the form,
       * ```
       * ⎡ a c e ⎤
       * ⎢ b d f ⎥
       * ⎣ 0 0 1 ⎦
       * ```
       */
    static fromCSSMatrix(cssString: string): Mat33;
}

/** An object that can be converted to a {@link Rect2}. */
interface RectTemplate {
    x: number;
    y: number;
    w?: number;
    h?: number;
    width?: number;
    height?: number;
}
/**
 * Represents a rectangle in 2D space, parallel to the XY axes.
 *
 * **Example**:
 * ```ts,runnable,console
 * import { Rect2, Vec2 } from '~/math/lib';
 *
 * const rect = Rect2.fromCorners(
 *   Vec2.of(0, 0),
 *   Vec2.of(10, 10),
 * );
 * console.log('area', rect.area);
 * console.log('topLeft', rect.topLeft);
 * ```
 *
 * `invariant: w ≥ 0, h ≥ 0, immutable`
 */
declare class Rect2 extends Abstract2DShape {
    readonly x: number;
    readonly y: number;
    readonly w: number;
    readonly h: number;
    readonly topLeft: IVec2;
    readonly size: IVec2;
    readonly area: number;
    constructor(x: number, y: number, w: number, h: number);
    translatedBy(vec: IVec2): Rect2;
    resizedTo(size: IVec2): Rect2;
    containsPoint(other: IVec2): boolean;
    /** @returns true iff `other` is completely within this `Rect2`. */
    containsRect(other: Rect2): boolean;
    /**
       * @returns true iff this and `other` overlap
       */
    intersects(other: Rect2): boolean;
    intersection(other: Rect2): Rect2 | null;
    union(other: Rect2): Rect2;
    divideIntoGrid(columns: number, rows: number): Rect2[];
    grownToPoint(point: IVec2, margin?: number): Rect2;
    grownBy(margin: number): Rect2;
    /**
       * If this rectangle is smaller than `minSize`, returns a copy of this
       * with a larger width/height.
       *
       * If smaller than `minSize`, padding is applied on both sides.
       */
    grownToSize(minSize: IVec2): Rect2;
    getClosestPointOnBoundaryTo(target: IVec2): IVec2;
    /**
       * Returns `true` iff all points in this rectangle are within `distance` from `point`:
       *
       * If $R$ is the set of points in this rectangle, returns `true` iff
       * $$
       * 	\forall {\bf a} \in R, \|\texttt{point} - {\bf a}\| < \texttt{radius}
       * $$
       */
    isWithinRadiusOf(radius: number, point: IVec2): boolean;
    get corners(): IVec2[];
    get maxDimension(): number;
    get minDimension(): number;
    get bottomRight(): IVec3;
    get topRight(): IVec3;
    get bottomLeft(): IVec3;
    get width(): number;
    get height(): number;
    get center(): {
        readonly x: number;
        readonly y: number;
        readonly z: number;
        readonly xy: {
            x: number;
            y: number;
        };
        at(idx: number): number;
        length(): number;
        magnitude(): number;
        magnitudeSquared(): number;
        squareDistanceTo(p: IVec3): number;
        distanceTo(p: IVec3): number;
        maximumEntryMagnitude(): number;
        angle(): number;
        normalized(): IVec3;
        normalizedOrZero(): IVec3;
        times(c: number): IVec3;
        plus(v: IVec3): IVec3;
        minus(v: IVec3): IVec3;
        dot(other: IVec3): number;
        cross(other: IVec3): IVec3;
        scale(other: IVec3 | number): IVec3;
        orthog(): IVec3;
        extend(distance: number, direction: IVec3): IVec3;
        lerp(target: IVec3, fractionTo: number): IVec3;
        zip(other: IVec3, zip: (componentInThis: number, componentInOther: number) => number): IVec3;
        map(fn: (component: number, index: number) => number): IVec3;
        asArray(): [number, number, number];
        eq(other: IVec3, fuzz?: number): boolean;
        toString(): string;
    };
    getEdges(): LineSegment2[];
    intersectsLineSegment(lineSegment: LineSegment2): IVec2[];
    signedDistance(point: IVec3): number;
    getTightBoundingBox(): Rect2;
    transformedBoundingBox(affineTransform: Mat33): Rect2;
    /** @return true iff this is equal to `other ± tolerance` */
    eq(other: Rect2, tolerance?: number): boolean;
    toString(): string;
    static fromCorners(corner1: IVec2, corner2: IVec2): Rect2;
    static bboxOf(points: IVec2[], margin?: number): Rect2;
    static union(...rects: Rect2[]): Rect2;
    static of(template: RectTemplate): Rect2;
    static empty: Rect2;
    static unitSquare: Rect2;
}

/**
 * An abstract base class for 2D shapes.
 */
declare abstract class Abstract2DShape {
    protected static readonly smallValue = 1e-12;
    /**
       * @returns the distance from `point` to this shape. If `point` is within this shape,
       * this returns the distance from `point` to the edge of this shape.
       *
       * @see {@link signedDistance}
       */
    distance(point: IVec2): number;
    /**
       * Computes the [signed distance function](https://en.wikipedia.org/wiki/Signed_distance_function)
       * for this shape.
       */
    abstract signedDistance(point: IVec2): number;
    /**
       * @returns points at which this shape intersects the given `lineSegment`.
       *
       * If this is a closed shape, returns points where the given `lineSegment` intersects
       * the **boundary** of this.
       */
    abstract intersectsLineSegment(lineSegment: LineSegment2): IVec2[];
    /**
       * Returns `true` if and only if the given `point` is contained within this shape.
       *
       * `epsilon` is a small number used to counteract floating point error. Thus, if
       * `point` is within `epsilon` of the inside of this shape, `containsPoint` may also
       * return `true`.
       *
       * The default implementation relies on `signedDistance`.
       * Subclasses may override this method to provide a more efficient implementation.
       */
    containsPoint(point: IVec2, epsilon?: number): boolean;
    /**
       * Returns a bounding box that precisely fits the content of this shape.
       *
       * **Note**: This bounding box should aligned with the x/y axes. (Thus, it may be
       * possible to find a tighter bounding box not axes-aligned).
       */
    abstract getTightBoundingBox(): Rect2;
    /**
       * Returns a bounding box that **loosely** fits the content of this shape.
       *
       * The result of this call can be larger than the result of {@link getTightBoundingBox},
       * **but should not be smaller**. Thus, a call to `getLooseBoundingBox` can be significantly
       * faster than a call to {@link getTightBoundingBox} for some shapes.
       */
    getLooseBoundingBox(): Rect2;
}

/**
 * A 2-dimensional path with parameter interval $t \in [0, 1]$.
 *
 * **Note:** Avoid extending this class outside of `easydrawer` --- new abstract methods
 * may be added between minor versions.
 */
declare abstract class Parameterized2DShape extends Abstract2DShape {
    /** Returns this at a given parameter. $t \in [0, 1]$ */
    abstract at(t: number): IVec2;
    /** Computes the unit normal vector at $t$. */
    abstract normalAt(t: number): IVec2;
    abstract tangentAt(t: number): IVec2;
    /**
       * Divides this shape into two separate shapes at parameter value $t$.
       */
    abstract splitAt(t: number): [Parameterized2DShape] | [Parameterized2DShape, Parameterized2DShape];
    /**
       * Returns the nearest point on `this` to `point` and the `parameterValue` at which
       * that point occurs.
       */
    abstract nearestPointTo(point: IVec2): {
        point: IVec2;
        parameterValue: number;
    };
    /**
       * Returns the **parameter values** at which `lineSegment` intersects this shape.
       *
       * See also {@link intersectsLineSegment}
       */
    abstract argIntersectsLineSegment(lineSegment: LineSegment2): number[];
    intersectsLineSegment(line: LineSegment2): IVec2[];
}

interface IntersectionResult$1 {
    point: IVec2;
    t: number;
}
/**
 * Represents a line segment. A `LineSegment2` is immutable.
 *
 * @example
 * ```ts,runnable,console
 * import {LineSegment2, Vec2} from '~/math/lib';
 * const l = new LineSegment2(Vec2.of(1, 1), Vec2.of(2, 2));
 * console.log('length: ', l.length);
 * console.log('direction: ', l.direction);
 * console.log('bounding box: ', l.bbox);
 * ```
 */
declare class LineSegment2 extends Parameterized2DShape {
    private readonly point1;
    private readonly point2;
    /**
       * The **unit** direction vector of this line segment, from
       * `point1` to `point2`.
       *
       * In other words, `direction` is `point2.minus(point1).normalized()`
       * (perhaps except when `point1` is equal to `point2`).
       */
    readonly direction: IVec2;
    /** The distance between `point1` and `point2`. */
    readonly length: number;
    /** The bounding box of this line segment. */
    readonly bbox: Rect2;
    /** Creates a new `LineSegment2` from its endpoints. */
    constructor(point1: IVec2, point2: IVec2);
    /**
       * Returns the smallest line segment that contains all points in `points`, or `null`
       * if no such line segment exists.
       *
       * @example
       * ```ts,runnable,console
       * import {LineSegment2, Vec2} from '~/math/lib';
       * console.log(LineSegment2.ofSmallestContainingPoints([Vec2.of(1, 0), Vec2.of(0, 1)]));
       * ```
       */
    static ofSmallestContainingPoints(points: readonly IVec2[]): LineSegment2 | null;
    /** Alias for `point1`. */
    get p1(): IVec2;
    /** Alias for `point2`. */
    get p2(): IVec2;
    get center(): IVec2;
    /**
       * Gets a point a **distance** `t` along this line.
       *
       * @deprecated
       */
    get(t: number): IVec2;
    /**
       * Returns a point a fraction, `t`, along this line segment.
       * Thus, `segment.at(0)` returns `segment.p1` and `segment.at(1)` returns
       * `segment.p2`.
       *
       * `t` should be in `[0, 1]`.
       */
    at(t: number): IVec2;
    normalAt(_t: number): IVec2;
    tangentAt(_t: number): IVec3;
    splitAt(t: number): [LineSegment2] | [LineSegment2, LineSegment2];
    /**
       * Returns the intersection of this with another line segment.
       *
       * **WARNING**: The parameter value returned by this method does not range from 0 to 1 and
       *              is currently a length.
       *              This will change in a future release.
       * @deprecated
       */
    intersection(other: LineSegment2): IntersectionResult$1 | null;
    intersects(other: LineSegment2): boolean;
    argIntersectsLineSegment(lineSegment: LineSegment2): number[];
    /**
       * Returns the points at which this line segment intersects the
       * given line segment.
       *
       * Note that {@link intersects} returns *whether* this line segment intersects another
       * line segment. This method, by contrast, returns **the point** at which the intersection
       * occurs, if such a point exists.
       */
    intersectsLineSegment(lineSegment: LineSegment2): IVec2[];
    closestPointTo(target: IVec2): IVec3;
    nearestPointTo(target: IVec3): {
        point: IVec3;
        parameterValue: number;
    };
    /**
       * Returns the distance from this line segment to `target`.
       *
       * Because a line segment has no interior, this signed distance is equivalent to
       * the full distance between `target` and this line segment.
       */
    signedDistance(target: IVec2): number;
    /** Returns a copy of this line segment transformed by the given `affineTransfm`. */
    transformedBy(affineTransfm: Mat33): LineSegment2;
    /** @inheritdoc */
    getTightBoundingBox(): Rect2;
    toString(): string;
    /**
       * Returns `true` iff this is equivalent to `other`.
       *
       * **Options**:
       * - `tolerance`: The maximum difference between endpoints. (Default: 0)
       * - `ignoreDirection`: Allow matching a version of `this` with opposite direction. (Default: `true`)
       */
    eq(other: LineSegment2, options?: {
        tolerance?: number;
        ignoreDirection?: boolean;
    }): boolean;
}

/** Identifiers for different path commands. These commands can make up a {@link Path}. */
declare enum PathCommandType {
    LineTo = 0,
    MoveTo = 1,
    CubicBezierTo = 2,
    QuadraticBezierTo = 3
}
interface CubicBezierPathCommand {
    kind: PathCommandType.CubicBezierTo;
    controlPoint1: IVec2;
    controlPoint2: IVec2;
    endPoint: IVec2;
}
interface QuadraticBezierPathCommand {
    kind: PathCommandType.QuadraticBezierTo;
    controlPoint: IVec2;
    endPoint: IVec2;
}
interface LinePathCommand {
    kind: PathCommandType.LineTo;
    point: IVec2;
}
interface MoveToPathCommand {
    kind: PathCommandType.MoveTo;
    point: IVec2;
}
type PathCommand = CubicBezierPathCommand | QuadraticBezierPathCommand | MoveToPathCommand | LinePathCommand;
interface IntersectionResult {
    curve: Parameterized2DShape;
    curveIndex: number;
    /** Parameter value for the closest point **on** the path to the intersection. @internal */
    parameterValue: number;
    /** Point at which the intersection occured. */
    point: IVec2;
}
/** Options for {@link Path.splitNear} and {@link Path.splitAt} */
interface PathSplitOptions {
    /**
       * Allows mapping points on newly added segments. This is useful, for example,
       * to round points to prevent long decimals when later saving.
       */
    mapNewPoint?: (point: IVec2) => IVec2;
}
/**
 * Allows indexing a particular part of a path.
 *
 * @see {@link Path.at} {@link Path.tangentAt}
 */
interface CurveIndexRecord {
    curveIndex: number;
    parameterValue: number;
}
/** Returns a positive number if `a` comes after `b`, 0 if equal, and negative otherwise. */
declare function compareCurveIndices(a: CurveIndexRecord, b: CurveIndexRecord): number;
/**
 * Returns a version of `index` with its parameter value incremented by `stepBy`
 * (which can be either positive or negative).
 */
declare function stepCurveIndexBy(index: CurveIndexRecord, stepBy: number): CurveIndexRecord;
/**
 * Represents a union of lines and curves.
 *
 * To create a path from a string, see {@link fromString}.
 *
 * @example
 * ```ts,runnable,console
 * import {Path, Mat33, Vec2, LineSegment2} from '~/math/lib';
 *
 * // Creates a path from an SVG path string.
 * // In this case,
 * // 1. Move to (0,0)
 * // 2. Line to (100,0)
 * const path = Path.fromString('M0,0 L100,0');
 *
 * // Logs the distance from (10,0) to the curve 1 unit
 * // away from path. This curve forms a stroke with the path at
 * // its center.
 * const strokeRadius = 1;
 * console.log(path.signedDistance(Vec2.of(10,0), strokeRadius));
 *
 * // Log a version of the path that's scaled by a factor of 4.
 * console.log(path.transformedBy(Mat33.scaling2D(4)).toString());
 *
 * // Log all intersections of a stroked version of the path with
 * // a vertical line segment.
 * // (Try removing the `strokeRadius` parameter).
 * const segment = new LineSegment2(Vec2.of(5, -100), Vec2.of(5, 100));
 * console.log(path.intersection(segment, strokeRadius).map(i => i.point));
 * ```
 */
declare class Path {
    readonly startPoint: IVec2;
    /**
       * A rough estimate of the bounding box of the path.
       * A slight overestimate.
       * See {@link getExactBBox}
       */
    readonly bbox: Rect2;
    /** The individual shapes that make up this path. */
    readonly parts: Readonly<PathCommand>[];
    /**
       * Creates a new `Path` that starts at `startPoint` and is made up of the path commands,
       * `parts`.
       *
       * See also {@link fromString}
       */
    constructor(startPoint: IVec2, parts: Readonly<PathCommand>[]);
    /**
       * Computes and returns the full bounding box for this path.
       *
       * If a slight over-estimate of a path's bounding box is sufficient, use
       * {@link bbox} instead.
       */
    getExactBBox(): Rect2;
    private cachedGeometry;
    get geometry(): Parameterized2DShape[];
    /**
       * Iterates through the start/end points of each component in this path.
       *
       * If a start point is equivalent to the end point of the previous segment,
       * the point is **not** emitted twice.
       */
    startEndPoints(): Generator<IVec2, undefined, unknown>;
    private cachedPolylineApproximation;
    polylineApproximation(): LineSegment2[];
    static computeBBoxForSegment(startPoint: IVec2, part: PathCommand): Rect2;
    /**
       * Returns the signed distance between `point` and a curve `strokeRadius` units
       * away from this path.
       *
       * This returns the **signed distance**, which means that points inside this shape
       * have their distance negated. For example,
       * ```ts,runnable,console
       * import {Path, Vec2} from '~/math/lib';
       * console.log(Path.fromString('m0,0 L100,0').signedDistance(Vec2.zero, 1));
       * ```
       * would print `-1` because (0,0) is on `m0,0 L100,0` and thus one unit away from its boundary.
       *
       * **Note**: `strokeRadius = strokeWidth / 2`
       */
    signedDistance(point: IVec2, strokeRadius: number): number;
    /**
       * Let `S` be a closed path a distance `strokeRadius` from this path.
       *
       * @returns Approximate intersections of `line` with `S` using ray marching, starting from
       * 	        both end points of `line` and each point in `additionalRaymarchStartPoints`.
       */
    private raymarchIntersectionWith;
    /**
       * Returns a list of intersections with this path. If `strokeRadius` is given,
       * intersections are approximated with the surface `strokeRadius` away from this.
       *
       * If `strokeRadius > 0`, the resultant `parameterValue` has no defined value.
       *
       * **Note**: `strokeRadius` is half of a stroke's width.
       */
    intersection(line: LineSegment2, strokeRadius?: number): IntersectionResult[];
    /**
       * @returns the nearest point on this path to the given `point`.
       */
    nearestPointTo(point: IVec2): IntersectionResult;
    at(index: CurveIndexRecord): IVec2;
    tangentAt(index: CurveIndexRecord): IVec2;
    /** Splits this path in two near the given `point`. */
    splitNear(point: IVec2, options?: PathSplitOptions): [Path] | [Path, Path];
    /**
       * Returns a copy of this path with `deleteFrom` until `deleteUntil` replaced with `insert`.
       *
       * This method is analogous to {@link Array.toSpliced}.
       */
    spliced(deleteFrom: CurveIndexRecord, deleteTo: CurveIndexRecord, insert: Path | undefined, options?: PathSplitOptions): Path;
    splitAt(at: CurveIndexRecord, options?: PathSplitOptions): [Path] | [Path, Path];
    splitAt(at: CurveIndexRecord[], options?: PathSplitOptions): Path[];
    /**
       * Replaces all `MoveTo` commands with `LineTo` commands and connects the end point of this
       * path to the start point.
       */
    asClosed(): Path;
    private static mapPathCommand;
    mapPoints(mapping: (point: IVec2) => IVec2): Path;
    transformedBy(affineTransfm: Mat33): Path;
    /**
       * @internal -- TODO: This method may have incorrect output in some cases.
       */
    closedContainsPoint(point: IVec2): boolean;
    /**
       * @returns `true` if this path (interpreted as a closed path) contains the given rectangle.
       */
    closedContainsRect(rect: Rect2): boolean;
    union(other: Path | PathCommand[] | null, options?: {
        allowReverse?: boolean;
    }): Path;
    /**
       * @returns a version of this path with the direction reversed.
       *
       * Example:
       * ```ts,runnable,console
       * import {Path} from '~/math/lib';
       * console.log(Path.fromString('m0,0l1,1').reversed()); // -> M1,1 L0,0
       * ```
       */
    reversed(): Path;
    /** Computes and returns the end point of this path */
    getEndPoint(): IVec2;
    /**
       * Like {@link closedRoughlyIntersects} except takes stroke width into account.
       *
       * This is intended to be a very fast and rough approximation. Use {@link intersection}
       * and {@link signedDistance} for more accurate (but much slower) intersection calculations.
       *
       * **Note**: Unlike other methods, this accepts `strokeWidth` (and not `strokeRadius`).
       *
       * `strokeRadius` is half of `strokeWidth`.
       */
    roughlyIntersects(rect: Rect2, strokeWidth?: number): boolean;
    /**
       * Treats this as a closed path and returns true if part of `rect` is *roughly* within
       * this path's interior.
       *
       * **Note**: Assumes that this is a closed, non-self-intersecting path.
       */
    closedRoughlyIntersects(rect: Rect2): boolean;
    /** @returns true if all points on this are equivalent to the points on `other` */
    eq(other: Path, tolerance?: number): boolean;
    /**
       * Returns a path that outlines `rect`.
       *
       * If `lineWidth` is given, the resultant path traces a `lineWidth` thick
       * border around `rect`. Otherwise, the resultant path is just the border
       * of `rect`.
       */
    static fromRect(rect: Rect2, lineWidth?: number | null): Path;
    private cachedStringVersion;
    /**
       * Convert to an [SVG path representation](https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths).
       *
       * If `useNonAbsCommands` is given, relative path commands (e.g. `l10,0`) are to be used instead of
       * absolute commands (e.g. `L10,0`).
       *
       * See also {@link fromString}.
       */
    toString(useNonAbsCommands?: boolean, ignoreCache?: boolean): string;
    serialize(): string;
    static toString(startPoint: IVec2, parts: PathCommand[], onlyAbsCommands?: boolean): string;
    /**
       * Create a `Path` from a subset of the SVG path specification.
       *
       * Currently, this does not support elliptical arcs or `s` and `t` command
       * shorthands. See https://github.com/personalizedrefrigerator/easydrawer/pull/19.
       *
       * @example
       * ```ts,runnable,console
       * import { Path } from '~/math/lib';
       *
       * const path = Path.fromString('m0,0l100,100');
       * console.log(path.toString(true)); // true: Prefer relative to absolute path commands
       * ```
       */
    static fromString(pathString: string): Path;
    static fromConvexHullOf(points: IVec2[]): Path;
    static empty: Path;
}

type TriangleBoundary = [LineSegment2, LineSegment2, LineSegment2];
declare class Triangle extends Abstract2DShape {
    #private;
    readonly vertex1: IVec3;
    readonly vertex2: IVec3;
    readonly vertex3: IVec3;
    /**
       * @see {@link fromVertices}
       */
    protected constructor(vertex1: IVec3, vertex2: IVec3, vertex3: IVec3);
    /**
       * Creates a triangle from its three corners. Corners may be stored in a different
       * order than given.
       */
    static fromVertices(vertex1: IVec3, vertex2: IVec3, vertex3: IVec3): Triangle;
    get vertices(): [IVec2, IVec2, IVec2];
    map(mapping: (vertex: IVec3) => IVec3): Triangle;
    transformed2DBy(affineTransform: Mat33): Triangle;
    transformedBy(linearTransform: Mat33): Triangle;
    /**
       * Returns the sides of this triangle, as an array of `LineSegment2`s.
       *
       * The first side is from `vertex1` to `vertex2`, the next from `vertex2` to `vertex3`,
       * and the last from `vertex3` to `vertex1`.
       */
    getEdges(): TriangleBoundary;
    intersectsLineSegment(lineSegment: LineSegment2): IVec3[];
    /** @inheritdoc */
    containsPoint(point: IVec3, epsilon?: number): boolean;
    /**
       * @returns the signed distance from `point` to the closest edge of this triangle.
       *
       * If `point` is inside `this`, the result is negative, otherwise, the result is
       * positive.
       */
    signedDistance(point: IVec3): number;
    /** @inheritdoc */
    getTightBoundingBox(): Rect2;
}

interface CorrectedBezierType extends Bezier {
    dderivative(t: number): {
        x: number;
        y: number;
    };
}
/**
 * A lazy-initializing wrapper around Bezier-js.
 *
 * Subclasses may override `at`, `derivativeAt`, and `normal` with functions
 * that do not initialize a `bezier-js` `Bezier`.
 *
 * **Do not use this class directly.** It may be removed/replaced in a future release.
 * @internal
 */
declare abstract class BezierJSWrapper extends Parameterized2DShape {
    #private;
    protected constructor(bezierJsBezier?: Bezier);
    /** Returns the start, control points, and end point of this Bézier. */
    abstract getPoints(): readonly IVec2[];
    protected getBezier(): CorrectedBezierType;
    signedDistance(point: IVec2): number;
    /**
       * @returns the (more) exact distance from `point` to this.
       *
       * @see {@link approximateDistance}
       */
    distance(point: IVec2): number;
    /**
       * @returns the curve evaluated at `t`.
       */
    at(t: number): IVec2;
    /** @returns the curve's directional derivative at `t`. */
    derivativeAt(t: number): IVec2;
    secondDerivativeAt(t: number): IVec2;
    /** @returns the [normal vector](https://en.wikipedia.org/wiki/Normal_(geometry)) to this curve at `t`. */
    normal(t: number): IVec2;
    normalAt(t: number): IVec2;
    tangentAt(t: number): IVec2;
    getTightBoundingBox(): Rect2;
    argIntersectsLineSegment(line: LineSegment2): number[];
    splitAt(t: number): [BezierJSWrapper] | [BezierJSWrapper, BezierJSWrapper];
    nearestPointTo(point: IVec2): {
        parameterValue: number;
        point: IVec2;
    };
    intersectsBezier(other: BezierJSWrapper): {
        parameterValue: number;
        point: IVec2;
    }[];
    toString(): string;
}

/**
 * Represents a 2D [Bézier curve](https://en.wikipedia.org/wiki/B%C3%A9zier_curve).
 *
 * Example:
 * ```ts,runnable,console
 * import { QuadraticBezier, Vec2 } from '~/math/lib';
 *
 * const startPoint = Vec2.of(4, 3);
 * const controlPoint = Vec2.of(1, 1);
 * const endPoint = Vec2.of(1, 3);
 *
 * const curve = new QuadraticBezier(
 *   startPoint,
 *   controlPoint,
 *   endPoint,
 * );
 *
 * console.log('Curve:', curve);
 * ```
 *
 * **Note**: Some Bézier operations internally use the `bezier-js` library.
 */
declare class QuadraticBezier extends BezierJSWrapper {
    readonly p0: IVec2;
    readonly p1: IVec2;
    readonly p2: IVec2;
    constructor(p0: IVec2, p1: IVec2, p2: IVec2);
    /**
       * Returns a component of a quadratic Bézier curve at t, where p0,p1,p2 are either all x or
       * all y components of the target curve.
       */
    private static componentAt;
    private static derivativeComponentAt;
    private static secondDerivativeComponentAt;
    /**
       * @returns the curve evaluated at `t`.
       *
       * `t` should be a number in `[0, 1]`.
       */
    at(t: number): IVec2;
    derivativeAt(t: number): IVec2;
    secondDerivativeAt(t: number): IVec2;
    normal(t: number): IVec2;
    /** @returns an overestimate of this shape's bounding box. */
    getLooseBoundingBox(): Rect2;
    /**
       * @returns the *approximate* distance from `point` to this curve.
       */
    approximateDistance(point: IVec2): number;
    getPoints(): IVec2[];
}

/**
 * Represents a color.
 *
 * @example
 * ```ts,runnable,console
 * import { Color4 } from '~/math/lib';
 *
 * console.log('Red:', Color4.fromString('#f00'));
 * console.log('Also red:', Color4.ofRGB(1, 0, 0), Color4.red);
 * console.log('Mixing red and blue:', Color4.red.mix(Color4.blue, 0.5));
 * console.log('To string:', Color4.orange.toHexString());
 * ```
 */
declare class Color4 {
    /** Red component. Should be in the range [0, 1]. */
    readonly r: number;
    /** Green component. ${\tt g} \in [0, 1]$ */
    readonly g: number;
    /** Blue component. ${\tt b} \in [0, 1]$ */
    readonly b: number;
    /** Alpha/transparent component. ${\tt a} \in [0, 1]$. 0 = transparent */
    readonly a: number;
    private constructor();
    /**
       * Create a color from red, green, blue components. The color is fully opaque (`a = 1.0`).
       *
       * Each component should be in the range [0, 1].
       */
    static ofRGB(red: number, green: number, blue: number): Color4;
    /**
       * Creates a color from red, green, blue, and transparency components. Each component should
       * be in the range $[0, 1]$.
       */
    static ofRGBA(red: number, green: number, blue: number, alpha: number): Color4;
    /**
       * Creates a color from an RGB (or RGBA) array.
       *
       * This is similar to {@link ofRGB} and {@link ofRGBA}, but, by default, takes values
       * that range from 0 to 255.
       *
       * If the array values instead range from 0-1, pass `maxValue` as `1`.
       */
    static fromRGBArray(array: Uint8Array | Uint8ClampedArray | number[], maxValue?: number): Color4;
    /**
       * Creates a `Color4` from a three or four-component hexadecimal
       * [color string](https://en.wikipedia.org/wiki/Web_colors#Hex_triplet).
       *
       * Example:
       * ```ts,runnable,console
       * import { Color4 } from '~/math/lib';
       * console.log(Color4.fromHex('#ff0'));
       * ```
       */
    static fromHex(hexString: string): Color4;
    /** Like {@link fromHex}, but can handle additional colors if an `HTMLCanvasElement` is available. */
    static fromString(text: string): Color4;
    /** @returns true if `this` and `other` are approximately equal. */
    eq(other: Color4 | null | undefined): boolean;
    /**
       * If `fractionTo` is not in the range $[0, 1]$, it will be clamped to the nearest number
       * in that range. For example, `a.mix(b, -1)` is equivalent to `a.mix(b, 0)`.
       *
       * @returns a color `fractionTo` of the way from this color to `other`.
       *
       * @example
       * ```ts
       * Color4.ofRGB(1, 0, 0).mix(Color4.ofRGB(0, 1, 0), 0.1) // -> Color4(0.9, 0.1, 0)
       * ```
       */
    mix(other: Color4, fractionTo: number): Color4;
    /** Returns a new color with a different opacity. */
    withAlpha(a: number): Color4;
    /**
       * Ignoring this color's alpha component, returns a vector with components,
       * $$
       * \begin{pmatrix} \colorbox{#F44}{\tt r} \\ \colorbox{#4F4}{\tt g} \\ \colorbox{#44F}{\tt b} \end{pmatrix}
       * $$
       */
    get rgb(): IVec3;
    /**
       * Returns the [relative luminance](https://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef)
       * of this color in the sRGB color space.
       *
       * Ignores the alpha component.
       */
    relativeLuminance(): number;
    /**
       * Returns the [contrast ratio](https://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef)
       * between `colorA` and `colorB`.
       */
    static contrastRatio(colorA: Color4, colorB: Color4): number;
    /**
       * @returns the component-wise average of `colors`, or `Color4.transparent` if `colors` is empty.
       */
    static average(colors: Color4[]): Color4;
    /**
       * Converts to (hue, saturation, value).
       * See also https://en.wikipedia.org/wiki/HSL_and_HSV#General_approach
       *
       * The resultant hue is represented in radians and is thus in $[0, 2\pi]$.
       */
    asHSV(): IVec3;
    /**
       * Creates a new `Color4` from a representation [in $HSV$](https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_RGB).
       *
       * [Algorithm](https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_RGB).
       *
       * Note that hue must be given **in radians**. While non-standard, this is consistent with
       * {@link asHSV}.
       *
       * `hue` and `value` should range from 0 to 1.
       *
       * @param hue $H \in [0, 2\pi]$
       * @param saturation $S_V \in [0, 1]$
       * @param value $V \in [0, 1]$
       */
    static fromHSV(hue: number, saturation: number, value: number): Color4;
    /**
       * Equivalent to `ofRGB(rgb.x, rgb.y, rgb.z)`.
       *
       * All components should be in the range `[0, 1]` (0 to 1 inclusive).
       */
    static fromRGBVector(rgb: IVec3, alpha?: number): Color4;
    private hexString;
    /**
       * @returns a hexadecimal color string representation of `this`, in the form `#rrggbbaa`.
       *
       * @example
       * ```
       * Color4.red.toHexString(); // -> #ff0000ff
       * ```
       */
    toHexString(): string;
    toString(): string;
    static transparent: Color4;
    static red: Color4;
    static orange: Color4;
    static green: Color4;
    static blue: Color4;
    static purple: Color4;
    static yellow: Color4;
    static clay: Color4;
    static black: Color4;
    static gray: Color4;
    static white: Color4;
    static blackHighlight: Color4;
    static redHighlight: Color4;
    static blueHighlight: Color4;
    static pink: Color4;
    static blueLight: Color4;
    static greenLight: Color4;
}

/**
 * Converts `num` to a string, removing trailing digits that were likely caused by
 * precision errors.
 *
 * @example
 * ```ts,runnable,console
 * import { toRoundedString } from '~/math/lib';
 *
 * console.log('Rounded: ', toRoundedString(1.000000011));
 * ```
 */
declare function toRoundedString(num: number): string;

interface CommandLocalization {
    movedLeft: string;
    movedUp: string;
    movedDown: string;
    movedRight: string;
    rotatedBy: (degrees: number) => string;
    zoomedOut: string;
    zoomedIn: string;
    erasedNoElements: string;
    duplicatedNoElements: string;
    elements: string;
    updatedViewport: string;
    transformedElements: (elemCount: number, transformDescription: string) => string;
    resizeOutputCommand: (newSize: Rect2) => string;
    enabledAutoresizeOutputCommand: string;
    disabledAutoresizeOutputCommand: string;
    addComponentAction: (elemDescription: string) => string;
    eraseAction: (elemDescription: string, numElems: number) => string;
    duplicateAction: (elemDescription: string, count: number) => string;
    inverseOf: (actionDescription: string) => string;
    unionOf: (actionDescription: string, actionCount: number) => string;
    andNMoreCommands: (count: number) => string;
    selectedElements: (count: number) => string;
}

interface ImageComponentLocalization {
    unlabeledImageNode: string;
    text: (text: string) => string;
    imageNode: (description: string) => string;
    stroke: string;
    svgObject: string;
    emptyBackground: string;
    gridBackground: string;
    dotBackground: string;
    filledBackgroundWithColor: (color: string) => string;
    restyledElement: (elementDescription: string) => string;
}

interface TextRendererLocalization {
    pathNodeCount(pathCount: number): string;
    textNodeCount(nodeCount: number): string;
    imageNodeCount(nodeCount: number): string;
    textNode(content: string): string;
    unlabeledImageNode: string;
    imageNode(label: string): string;
    rerenderAsText: string;
}

interface ToolbarUtilsLocalization {
    help: string;
    helpScreenNavigationHelp: string;
    helpControlsAccessibilityLabel: string;
    helpHidden: string;
    next: string;
    previous: string;
    close: string;
}

interface ToolbarLocalization extends ToolbarUtilsLocalization {
    fontLabel: string;
    textSize: string;
    touchPanning: string;
    lockRotation: string;
    outlinedRectanglePen: string;
    outlinedCirclePen: string;
    filledSquare: string;
    filledRectangle: string;
    filledCircle: string;
    filledTriangle: string;
    filledHexagonal: string;
    filledDiamond: string;
    filledArrow: string;
    linePen: string;
    arrowPen: string;
    image: string;
    inputAltText: string;
    decreaseImageSize: string;
    resetImage: string;
    chooseFile: string;
    dragAndDropHereOrBrowse: string;
    cancel: string;
    submit: string;
    addAll: string;
    roundedTipPen: string;
    roundedTipPen2: string;
    flatTipPen: string;
    selectPenType: string;
    selectShape: string;
    colorLabel: string;
    pen: string;
    eraser: string;
    select: string;
    handTool: string;
    thicknessLabel: string;
    resizeImageToSelection: string;
    deleteSelection: string;
    duplicateSelection: string;
    fullStrokeEraser: string;
    pickColorFromScreen: string;
    clickToPickColorAnnouncement: string;
    colorSelectionCanceledAnnouncement: string;
    undo: string;
    redo: string;
    exit: string;
    save: string;
    zoom: string;
    resetView: string;
    reformatSelection: string;
    selectionToolKeyboardShortcuts: string;
    selectionTool__lassoSelect: string;
    selectionTool__lassoSelect__help: string;
    paste: string;
    documentProperties: string;
    backgroundColor: string;
    imageWidthOption: string;
    imageHeightOption: string;
    useGridOption: string;
    enableAutoresizeOption: string;
    toggleOverflow: string;
    about: string;
    inputStabilization: string;
    strokeAutocorrect: string;
    errorImageHasZeroSize: string;
    describeTheImage: string;
    fileInput__loading: string;
    fileInput__andNMoreFiles: (count: number) => string;
    penDropdown__baseHelpText: string;
    penDropdown__colorHelpText: string;
    penDropdown__thicknessHelpText: string;
    penDropdown__penTypeHelpText: string;
    penDropdown__autocorrectHelpText: string;
    penDropdown__stabilizationHelpText: string;
    handDropdown__baseHelpText: string;
    handDropdown__zoomDisplayHelpText: string;
    handDropdown__zoomInHelpText: string;
    handDropdown__zoomOutHelpText: string;
    handDropdown__resetViewHelpText: string;
    handDropdown__touchPanningHelpText: string;
    eraserDropdown__baseHelpText: string;
    eraserDropdown__fullStrokeEraserHelpText: string;
    handDropdown__lockRotationHelpText: string;
    eraserDropdown__thicknessHelpText: string;
    selectionDropdown__baseHelpText: string;
    selectionDropdown__resizeToHelpText: string;
    selectionDropdown__deleteHelpText: string;
    selectionDropdown__duplicateHelpText: string;
    selectionDropdown__changeColorHelpText: string;
    pageDropdown__baseHelpText: string;
    pageDropdown__backgroundColorHelpText: string;
    pageDropdown__gridCheckboxHelpText: string;
    pageDropdown__aboutButtonHelpText: string;
    pageDropdown__autoresizeCheckboxHelpText: string;
    colorPickerPipetteHelpText: string;
    colorPickerToggleHelpText: string;
    closeSidebar: (toolName: string) => string;
    dropdownShown: (toolName: string) => string;
    dropdownHidden: (toolName: string) => string;
    zoomLevel: (zoomPercentage: number) => string;
    colorChangedAnnouncement: (color: string) => string;
    imageSize: (size: number, units: string) => string;
    imageLoadError: (message: string) => string;
}

interface ToolLocalization {
    keyboardPanZoom: string;
    penTool: (penId: number) => string;
    selectionTool: string;
    selectAllTool: string;
    eraserTool: string;
    touchPanTool: string;
    twoFingerPanZoomTool: string;
    undoRedoTool: string;
    pipetteTool: string;
    rightClickDragPanTool: string;
    autocorrectedTo: (description: string) => string;
    autocorrectionCanceled: string;
    textTool: string;
    enterTextToInsert: string;
    changeTool: string;
    pasteHandler: string;
    soundExplorer: string;
    disableAccessibilityExploreTool: string;
    enableAccessibilityExploreTool: string;
    soundExplorerUsageAnnouncement: string;
    findLabel: string;
    toNextMatch: string;
    closeDialog: string;
    findDialogShown: string;
    findDialogHidden: string;
    focusedFoundText: (currentMatchNumber: number, totalMatches: number) => string;
    anyDevicePanning: string;
    selectionMenu__show: string;
    selectionMenu__copyToClipboard: string;
    selectionMenu__duplicate: string;
    selectionMenu__delete: string;
    selectionMenu__paste: string;
    copied: (count: number) => string;
    pasted: (count: number) => string;
    copyPasteError__heading: string;
    copyPasteError__description: string;
    copyPasteError__pasteRetry: string;
    copyPasteError__copyRetry: string;
    copyPasteError__copyMe: string;
    copyPasteError__errorDetails: string;
    toolEnabledAnnouncement: (toolName: string) => string;
    toolDisabledAnnouncement: (toolName: string) => string;
}

interface EditorLocalization extends ToolbarLocalization, ToolLocalization, CommandLocalization, ImageComponentLocalization, TextRendererLocalization {
    accessibilityInputInstructions: string;
    undoAnnouncement: (actionDescription: string) => string;
    redoAnnouncement: (actionDescription: string) => string;
    doneLoading: string;
    loading: (percentage: number) => string;
    imageEditor: string;
    softwareLibraries: string;
    developerInformation: string;
}
declare const defaultEditorLocalization: EditorLocalization;

/**
 * A `Command` is an action that can be done, redone, and undone. It's used to enable undo/redo.
 *
 * See {@link Editor.dispatch}.
 */
declare abstract class Command {
    abstract apply(editor: Editor): Promise<void> | void;
    abstract unapply(editor: Editor): Promise<void> | void;
    onDrop(_editor: Editor): void;
    abstract description(editor: Editor, localizationTable: EditorLocalization): string;
    /** @deprecated Use {@link uniteCommands} */
    static union(a: Command, b: Command): Command;
    static readonly empty: {
        description(_editor: Editor, _localizationTable: EditorLocalization): string;
        apply(_editor: Editor): void;
        unapply(_editor: Editor): void;
        onDrop(_editor: Editor): void;
    };
}

type DeserializationCallback = (data: Record<string, any> | any[], editor: Editor) => SerializableCommand;
/**
 * A command that can be serialized to or deserialized from JSON. To allow a command to be deserialized, {@link SerializableCommand.register}
 * must be called for each {@link SerializableCommand}.
 *
 * This is used to [allow collaborative editing](https://github.com/personalizedrefrigerator/easydrawer/tree/main/docs/examples/example-collaborative).
 */
declare abstract class SerializableCommand extends Command {
    #private;
    /** @param commandTypeId - A unique identifier for this command. */
    constructor(commandTypeId: string);
    protected abstract serializeToJSON(): string | Record<string, any> | any[];
    private static deserializationCallbacks;
    serialize(): Record<string | symbol, any>;
    static deserialize(data: string | Record<string, any>, editor: Editor): SerializableCommand;
    static register(commandTypeId: string, deserialize: DeserializationCallback): void;
}

type CallbackHandler<EventType> = (data: EventType) => void;
interface DispatcherEventListener {
    remove: () => void;
}
/**
 * Handles notifying listeners of events.
 *
 * `EventKeyType` is used to distinguish events (e.g. a `ClickEvent` vs a `TouchEvent`)
 * while `EventMessageType` is the type of the data sent with an event (can be `void`).
 *
 * @example
 * ```
 * const dispatcher = new EventDispatcher<'event1'|'event2'|'event3', void>();
 * dispatcher.on('event1', () => {
 *   console.log('Event 1 triggered.');
 * });
 * dispatcher.dispatch('event1');
 * ```
 *
 */
declare class EventDispatcher<EventKeyType extends string | symbol | number, EventMessageType> {
    private listeners;
    constructor();
    dispatch(eventName: EventKeyType, event: EventMessageType): void;
    on(eventName: EventKeyType, callback: CallbackHandler<EventMessageType>): DispatcherEventListener;
    /** Removes an event listener. This is equivalent to calling `.remove()` on the object returned by `.on`. */
    off(eventName: EventKeyType, callback: CallbackHandler<EventMessageType>): void;
}

type ListenerResult = {
    remove(): void;
};
type UpdateCallback<T> = (value: T) => void;
type ReactiveValuesOf<T extends unknown[]> = {
    [key in keyof T]: ReactiveValue<T[key]>;
};
/**
 * A `ReactiveValue` is a value that
 * - updates periodically,
 * - can fire listeners when it updates,
 * - and can be chanined together with other `ReactiveValue`s.
 *
 * A `ReactiveValue` is a read-only view. See {@link MutableReactiveValue} for a
 * read-write view.
 *
 * Static methods in the `ReactiveValue` and `MutableReactiveValue` classes are
 * constructors (e.g. `fromImmutable`).
 *
 * Avoid extending this class from an external library, as that may not be stable.
 */
declare abstract class ReactiveValue<T> {
    /**
       * Returns a reference to the current value of this `ReactiveValue`.
       *
       * The result of this **should not be modified** (use `setValue` instead).
       */
    abstract get(): T;
    /**
       * Registers a listener that is notified when the value of this changes.
       */
    abstract onUpdate(listener: UpdateCallback<T>): ListenerResult;
    /**
       * Calls `callback` immediately, then registers `callback` as an onUpdateListener.
       *
       * @see {@link onUpdate}.
       */
    abstract onUpdateAndNow(callback: UpdateCallback<T>): ListenerResult;
    /** Returns a promise that resolves when this value is next changed. */
    waitForNextUpdate(): Promise<T>;
    /** Creates a `ReactiveValue` with an initial value, `initialValue`. */
    static fromInitialValue<T>(initialValue: T): MutableReactiveValue<T>;
    /** Returns a `ReactiveValue` that is **known** will never change. */
    static fromImmutable<T>(value: T): ReactiveValue<T>;
    /**
       * Creates a `ReactiveValue` whose values come from `callback`.
       *
       * `callback` is called whenever any of `sourceValues` are updated and initially to
       * set the initial value of the result.
       */
    static fromCallback<T>(callback: () => T, sourceValues: ReactiveValue<any>[]): ReactiveValue<T>;
    /**
       * Returns a reactive value derived from a single `source`.
       *
       * If `inverseMap` is `undefined`, the result is a read-only view.
       */
    static map<A, B>(source: ReactiveValue<A>, map: (a: A) => B, inverseMap?: undefined): ReactiveValue<B>;
    /**
       * Returns a reactive value derived from a single `source`.
       */
    static map<A, B>(source: ReactiveValue<A>, map: (a: A) => B, inverseMap: (b: B) => A): MutableReactiveValue<B>;
    static union<Values extends [...unknown[]]>(values: ReactiveValuesOf<Values>): ReactiveValue<Values>;
}
declare abstract class MutableReactiveValue<T> extends ReactiveValue<T> {
    /**
       * Changes the value of this and, if different, fires all update listeners.
       *
       * @see {@link onUpdate}
       */
    abstract set(newValue: T): void;
    static fromProperty<SourceType extends object, Name extends keyof SourceType>(sourceValue: MutableReactiveValue<SourceType>, propertyName: Name): MutableReactiveValue<SourceType[Name]>;
}

/**
 * A class that manages whether/what content is shown for a widget.
 *
 * This might be a dropdown menu or a sidebar.
 *
 * TODO: Shouldn't be an interface, unless always internal.
 * @internal
 */
interface ToolMenu {
    /**
       * Request that the layout manager show the dropdown. In general,
       * this makes the content of the dropdown visible.
       */
    requestShow(): void;
    /**
       * Request that the layout manager hide the dropdown. Even after calling this,
       * the dropdown may still be visible.
       */
    requestHide(): void;
    /** Whether the dropdown is visible (not hidden). */
    readonly visible: ReactiveValue<boolean>;
    /** Note that the tool associated with this dropdown has been activated. */
    onActivated(): void;
    /** Adds the given `child` to the content of the dropdown. */
    appendChild(child: HTMLElement): void;
    /** Removes all children from this dropdown. */
    clearChildren(): void;
    /**
       * Destroy the dropdown and remove it from the document. This should be called when
       * the creator of the dropdown is destroyed.
       */
    destroy(): void;
}
/**
 * Provides information about the element a tool menu is attached to.
 */
interface ToolMenuParent {
    /** The dropdown may be added **after** this element. */
    target: HTMLElement;
    /**
       * @returns the title of the element the dropdown is associated with.
       *
       * This is used for accessibility announcements (and possibly to display
       * a heading).
       */
    getTitle(): string;
    /**
       * Returns true iff the parent is a toplevel element (not contained within
       * a ContentLayoutManager of the same type as the current).
       */
    isToplevel(): boolean;
}
interface WidgetContentLayoutManager {
    /**
       * Creates a tool menu (e.g. a dropdown). The dropdown *may* be added to `parent` or addded
       * elsewhere (this depends on the layout manager).
       *
       * Regardless, `parent` should be a place where an absolutely-positioned dropdown
       * element could be added.
       */
    createToolMenu(parent: ToolMenuParent): ToolMenu;
}

declare enum PointerDevice {
    Pen = 0,
    Eraser = 1,
    Touch = 2,
    PrimaryButtonMouse = 3,
    RightButtonMouse = 4,
    Other = 5
}
declare class Pointer {
    readonly screenPos: IVec2;
    readonly canvasPos: IVec2;
    readonly pressure: number | null;
    readonly isPrimary: boolean;
    readonly down: boolean;
    readonly device: PointerDevice;
    readonly id: number;
    readonly timeStamp: number;
    private constructor();
    /**
       * Snaps this pointer to the nearest grid point (rounds the coordinates of this
       * pointer based on the current zoom). Returns a new Pointer and does not modify
       * this.
       */
    snappedToGrid(viewport: Viewport): Pointer;
    lockedToXYAxesScreen(originPointScreen: IVec2, viewport: Viewport): Pointer;
    /** @see {@link withCanvasPosition} */
    withScreenPosition(screenPos: IVec2, viewport: Viewport): Pointer;
    /** Returns a copy of this pointer with a changed timestamp. */
    withTimestamp(timeStamp: number): Pointer;
    /**
       * Returns a copy of this pointer with a new position. The screen position is determined
       * by the given `canvasPos`.
       */
    withCanvasPosition(canvasPos: IVec2, viewport: Viewport): Pointer;
    static ofEvent(evt: PointerEvent, isDown: boolean, viewport: Viewport, relativeTo?: HTMLElement): Pointer;
    static ofCanvasPoint(canvasPos: IVec2, isDown: boolean, viewport: Viewport, id?: number, device?: PointerDevice, isPrimary?: boolean, pressure?: number | null, timeStamp?: number | null): Pointer;
    static ofScreenPoint(screenPos: IVec2, isDown: boolean, viewport: Viewport, id?: number, device?: PointerDevice, isPrimary?: boolean, pressure?: number | null, timeStamp?: number | null): Pointer;
}

type HTMLPointerEventName = 'pointerdown' | 'pointermove' | 'pointerup' | 'pointercancel';
type HTMLPointerEventFilter = (eventName: HTMLPointerEventName, event: PointerEvent) => boolean;
interface PointerEvtListener {
    onPointerDown(event: PointerEvt): boolean;
    onPointerMove(event: PointerEvt): void;
    onPointerUp(event: PointerEvt): void;
    onGestureCancel(): void;
}
declare enum InputEvtType {
    PointerDownEvt = 0,
    PointerMoveEvt = 1,
    PointerUpEvt = 2,
    GestureCancelEvt = 3,
    WheelEvt = 4,
    KeyPressEvent = 5,
    KeyUpEvent = 6,
    CopyEvent = 7,
    PasteEvent = 8,
    ContextMenu = 9
}
interface WheelEvt {
    readonly kind: InputEvtType.WheelEvt;
    readonly delta: IVec3;
    readonly screenPos: IVec2;
}
interface BaseKeyEvent {
    readonly key: string;
    readonly code: string;
    readonly ctrlKey: boolean | undefined;
    readonly altKey: boolean | undefined;
    readonly shiftKey: boolean | undefined;
}
/**
 * Represents a keydown or auto-repeated keydown event.
 *
 * Use {@link keyPressEventFromHTMLEvent} where possible rather than
 * constructing directly (required properties may change between minor
 * releases).
 */
interface KeyPressEvent extends BaseKeyEvent {
    readonly kind: InputEvtType.KeyPressEvent;
}
/**
 * Represents a key release or auto-repeated key releae event.
 *
 * Use {@link keyUpEventFromHTMLEvent} where possible rather than
 * constructing directly (required properties may change between minor
 * releases).
 */
interface KeyUpEvent extends BaseKeyEvent {
    readonly kind: InputEvtType.KeyUpEvent;
}
interface CopyEvent {
    readonly kind: InputEvtType.CopyEvent;
    setData(mime: string, data: string | Promise<Blob>): void;
}
interface PasteEvent {
    readonly kind: InputEvtType.PasteEvent;
    readonly data: string;
    readonly mime: string;
}
interface GestureCancelEvt {
    readonly kind: InputEvtType.GestureCancelEvt;
}
interface PointerEvtBase {
    readonly current: Pointer;
    readonly allPointers: Pointer[];
}
interface PointerDownEvt extends PointerEvtBase {
    readonly kind: InputEvtType.PointerDownEvt;
}
interface PointerMoveEvt extends PointerEvtBase {
    readonly kind: InputEvtType.PointerMoveEvt;
}
interface PointerUpEvt extends PointerEvtBase {
    readonly kind: InputEvtType.PointerUpEvt;
}
interface ContextMenuEvt {
    readonly kind: InputEvtType.ContextMenu;
    readonly screenPos: IVec2;
    readonly canvasPos: IVec2;
}
/**
 * An internal `easydrawer` pointer event type.
 *
 * This **is not** the same as a DOM pointer event.
 */
type PointerEvt = PointerDownEvt | PointerMoveEvt | PointerUpEvt;
/** The type of any internal {@link PointerEvt} record. */
type PointerEvtType = InputEvtType.PointerDownEvt | InputEvtType.PointerMoveEvt | InputEvtType.PointerUpEvt;
/**
 * An internal `easydrawer` input event type.
 *
 * These are not DOM events.
 */
type InputEvt = KeyPressEvent | KeyUpEvent | WheelEvt | GestureCancelEvt | PointerEvt | CopyEvent | PasteEvent | ContextMenuEvt;
declare function keyUpEventFromHTMLEvent(event: KeyboardEvent): KeyUpEvent;
declare function keyPressEventFromHTMLEvent(event: KeyboardEvent): KeyPressEvent;
declare function isPointerEvt(event: InputEvt): event is PointerEvt;

type OnEventCallback = (event: InputEvt) => boolean;
interface InputEventListener {
    onEvent: OnEventCallback;
}
/**
 * Accepts input events and emits input events.
 */
declare abstract class InputMapper implements InputEventListener {
    #private;
    constructor();
    setEmitListener(listener: InputEventListener | OnEventCallback | null): void;
    protected emit(event: InputEvt): boolean;
    /**
       * @returns true if the given `event` should be considered "handled" by the app and thus not
       * forwarded to other targets. For example, returning "true" for a touchpad pinch event prevents
       * the pinch event from zooming the webpage.
       *
       * Generally, this should return the result of calling `this.emit` with some event.
       */
    abstract onEvent(event: InputEvt): boolean;
}

declare class ToolEnabledGroup {
    private activeTool;
    constructor();
    notifyEnabled(tool: BaseTool): void;
    setEnabled(tool: BaseTool): void;
}

declare abstract class BaseTool implements InputEventListener {
    #private;
    private notifier;
    readonly description: string;
    protected constructor(notifier: EditorNotifier, description: string);
    /** Override this to allow this tool to be enabled in a read-only editor */
    canReceiveInputInReadOnlyEditor(): boolean;
    setInputMapper(mapper: InputMapper | null): void;
    getInputMapper(): InputMapper | null;
    private dispatchEventToCallback;
    onEvent(event: InputEvt): boolean;
    /**
       * Returns true iff the tool handled the event and thus should receive additional
       * events.
       */
    onPointerDown(_event: PointerDownEvt): boolean;
    onPointerMove(_event: PointerMoveEvt): void;
    /**
       * Returns true iff there are additional pointers down and the tool should
       * remain active to handle the additional events.
       *
       * For most purposes, this should return `false` or nothing.
       */
    onPointerUp(_event: PointerUpEvt): boolean | void;
    onGestureCancel(_event: GestureCancelEvt): void;
    onWheel(_event: WheelEvt): boolean;
    onCopy(_event: CopyEvent): boolean;
    onPaste(_event: PasteEvent): boolean;
    onKeyPress(_event: KeyPressEvent): boolean;
    onKeyUp(_event: KeyUpEvent): boolean;
    onContextMenu(_event: ContextMenuEvt): boolean;
    /**
       * Return true if, while this tool is active, `_event` can be delivered to
       * another tool that is higher priority than this.
       * @internal May be renamed
       */
    eventCanBeDeliveredToNonActiveTool(_event: PointerEvt): boolean;
    setEnabled(enabled: boolean): void;
    isEnabled(): boolean;
    /**
       * Returns a {@link ReactiveValue} that updates based on whether this tool is
       * enabled.
       *
       * @example
       * ```ts
       * const tool = new SomeTool();
       *
       * // Watch for changes in enabled status
       * tool.enabledValue().onUpdate(enabled => doSomething(enabled));
       * ```
       */
    enabledValue(): ReactiveValue<boolean>;
    setToolGroup(group: ToolEnabledGroup): void;
    getToolGroup(): ToolEnabledGroup | null;
    onDestroy(): void;
}

/**
 * The type of the {@link Editor.notifier}, which provides notifications for
 * various editor-related events.
 */
type EditorNotifier = EventDispatcher<EditorEventType, EditorEventDataType>;
/** @see {@link EditorNotifier} */
declare enum EditorEventType {
    ToolEnabled = 0,
    ToolDisabled = 1,
    ToolUpdated = 2,
    UndoRedoStackUpdated = 3,
    CommandDone = 4,
    CommandUndone = 5,
    ObjectAdded = 6,
    ViewportChanged = 7,
    DisplayResized = 8,
    SelectionUpdated = 9,
    ReadOnlyModeToggled = 10,
    /** @internal */
    ColorPickerToggled = 11,
    /** @internal */
    ColorPickerColorSelected = 12,
    /** @deprecated @internal */
    ToolbarDropdownShown = 13
}
declare enum UndoEventType {
    CommandDone = 0,
    CommandUndone = 1,
    CommandRedone = 2
}
type EditorToolEventType = EditorEventType.ToolEnabled | EditorEventType.ToolDisabled | EditorEventType.ToolUpdated;
interface EditorToolEvent {
    readonly kind: EditorToolEventType;
    readonly tool: BaseTool;
}
interface EditorObjectEvent {
    readonly kind: EditorEventType.ObjectAdded;
    readonly object: AbstractComponent;
}
interface EditorViewportChangedEvent {
    readonly kind: EditorEventType.ViewportChanged;
    readonly newTransform: Mat33;
    readonly oldTransform: Mat33;
}
interface DisplayResizedEvent {
    readonly kind: EditorEventType.DisplayResized;
    readonly newSize: IVec2;
}
interface EditorUndoStackUpdated {
    readonly kind: EditorEventType.UndoRedoStackUpdated;
    readonly undoStackSize: number;
    readonly redoStackSize: number;
    readonly command?: Command;
    readonly stackUpdateType: UndoEventType;
}
interface CommandDoneEvent {
    readonly kind: EditorEventType.CommandDone;
    readonly command: Command;
}
interface CommandUndoneEvent {
    readonly kind: EditorEventType.CommandUndone;
    readonly command: Command;
}
interface SelectionUpdated {
    readonly kind: EditorEventType.SelectionUpdated;
    readonly selectedComponents: AbstractComponent[];
    readonly tool: BaseTool;
}
interface ReadOnlyToggled {
    readonly kind: EditorEventType.ReadOnlyModeToggled;
    readonly editorIsReadOnly: boolean;
}
interface ColorPickerToggled {
    readonly kind: EditorEventType.ColorPickerToggled;
    readonly open: boolean;
}
interface ColorPickerColorSelected {
    readonly kind: EditorEventType.ColorPickerColorSelected;
    readonly color: Color4;
}
interface ToolbarDropdownShownEvent {
    readonly kind: EditorEventType.ToolbarDropdownShown;
    readonly fromToplevelDropdown: boolean;
    readonly layoutManager: WidgetContentLayoutManager;
}
type EditorEventDataType = EditorToolEvent | EditorObjectEvent | EditorViewportChangedEvent | DisplayResizedEvent | EditorUndoStackUpdated | CommandDoneEvent | CommandUndoneEvent | SelectionUpdated | ReadOnlyToggled | ColorPickerToggled | ColorPickerColorSelected | ToolbarDropdownShownEvent;
type OnProgressListener = (amountProcessed: number, totalToProcess: number) => Promise<void> | null | void;
type ComponentAddedListener = (component: AbstractComponent) => Promise<void> | void;
type OnDetermineExportRectListener = (exportRect: Rect2, options?: {
    autoresize: boolean;
}) => void;
interface ImageLoader {
    start(onAddComponent: ComponentAddedListener, onProgressListener: OnProgressListener, onDetermineExportRect?: OnDetermineExportRectListener): Promise<void>;
}
interface StrokeDataPoint {
    pos: IVec2;
    width: number;
    /** Time in milliseconds (e.g. as returned by `performance.now()`). */
    time: number;
    color: Color4;
    borderColor?: Color4;
}

type PointDataType<T extends IVec2 | StrokeDataPoint | number> = T extends IVec2 ? IVec2 : number;
declare abstract class ViewportTransform extends Command {
    abstract readonly transform: Mat33;
}
type TransformChangeCallback = (oldTransform: Mat33, newTransform: Mat33) => void;
declare class Viewport {
    private onTransformChangeCallback;
    private static ViewportTransform;
    /** Converts from canvas to screen coordinates */
    private transform;
    /** Converts from screen to canvas coordinates */
    private inverseTransform;
    private screenRect;
    constructor(onTransformChangeCallback: TransformChangeCallback);
    /**
       * @returns a temporary copy of `this` that does not notify when modified. This is
       * useful when rendering with a temporarily different viewport.
       */
    getTemporaryClone(): Viewport;
    /** Resizes the screen rect to the given size. @internal */
    updateScreenSize(screenSize: IVec2): void;
    /** Get the screen's visible region transformed into canvas space. */
    get visibleRect(): Rect2;
    /** @returns the given point, but in canvas coordinates */
    screenToCanvas(screenPoint: IVec2): IVec2;
    /** @returns the given point transformed into screen coordinates. */
    canvasToScreen(canvasPoint: IVec2): IVec2;
    /**
       * @returns a command that transforms the canvas by `transform`.
       *
       * For example, `Viewport.transformBy(moveRight).apply(editor)` would move the canvas to the right
       * (and thus the viewport to the left):
       * ```ts,runnable
       * import { Editor, Viewport, Mat33, Vec2 } from 'easydrawer';
       * const editor = new Editor(document.body);
       * const moveRight = Mat33.translation(Vec2.unitX.times(500));
       * // Move the **canvas** right by 500 units:
       * Viewport.transformBy(moveRight).apply(editor);
       * ```
       */
    static transformBy(transform: Mat33): ViewportTransform;
    /**
       * Updates the transformation directly. Using `transformBy` is preferred.
       * @param newTransform - should map from canvas coordinates to screen coordinates.
       */
    resetTransform(newTransform?: Mat33): void;
    get screenToCanvasTransform(): Mat33;
    get canvasToScreenTransform(): Mat33;
    /** @returns the size of the visible region in pixels (screen units). */
    getScreenRectSize(): IVec2;
    /** Alias for `getScreenRectSize`. @deprecated */
    getResolution(): IVec2;
    /** @returns the amount a vector on the canvas is scaled to become a vector on the screen. */
    getScaleFactor(): number;
    /**
       * @returns `getScaleFactor()` rounded to the nearest power of 10.
       * For example, if `getScaleFactor()` returns 101, `getScaleFactorToNearestPowerOfTen()`
       * should return `100` because `100` is the nearest power of 10 to 101.
       */
    getScaleFactorToNearestPowerOfTen(): number;
    private getScaleFactorToNearestPowerOf;
    /** Returns the size of a grid cell (in canvas units) as used by {@link snapToGrid}. */
    static getGridSize(scaleFactor: number): number;
    /**
       * Snaps `canvasPos` to the nearest grid cell corner.
       *
       * @see {@link getGridSize}.
       */
    snapToGrid(canvasPos: IVec2): {
        readonly x: number;
        readonly y: number;
        readonly z: number;
        readonly xy: {
            x: number;
            y: number;
        };
        at(idx: number): number;
        length(): number;
        magnitude(): number;
        magnitudeSquared(): number;
        squareDistanceTo(p: IVec3): number;
        distanceTo(p: IVec3): number;
        maximumEntryMagnitude(): number;
        angle(): number;
        normalized(): IVec3;
        normalizedOrZero(): IVec3;
        times(c: number): IVec3;
        plus(v: IVec3): IVec3;
        minus(v: IVec3): IVec3;
        dot(other: IVec3): number;
        cross(other: IVec3): IVec3;
        scale(other: IVec3 | number): IVec3;
        orthog(): IVec3;
        extend(distance: number, direction: IVec3): IVec3;
        lerp(target: IVec3, fractionTo: number): IVec3;
        zip(other: IVec3, zip: (componentInThis: number, componentInOther: number) => number): IVec3;
        map(fn: (component: number, index: number) => number): IVec3;
        asArray(): [number, number, number];
        eq(other: IVec3, fuzz?: number): boolean;
        toString(): string;
    };
    /** Returns the size of one screen pixel in canvas units. */
    getSizeOfPixelOnCanvas(): number;
    /**
       * @returns the angle of the canvas in radians.
       * This is the angle by which the canvas is rotated relative to the screen.
       *
       * Returns an angle in the range $[-\pi, \pi]$ (the same range as {@link Vec3.angle}).
       */
    getRotationAngle(): number;
    /**
       * Rounds the given `point` to a multiple of 10 such that it is within `tolerance` of
       * its original location. This is useful for preparing data for base-10 conversion.
       */
    static roundPoint<T extends IVec2 | number>(point: T, tolerance: number): PointDataType<T>;
    /** Round a point with a tolerance of ±1 screen unit. */
    roundPoint(point: IVec2): IVec2;
    static roundScaleRatio(scaleRatio: number, roundAmount?: number): number;
    computeZoomToTransform(toMakeVisible: Rect2, allowZoomIn?: boolean, allowZoomOut?: boolean): Mat33;
    zoomTo(toMakeVisible: Rect2, allowZoomIn?: boolean, allowZoomOut?: boolean): Command;
}

interface StrokeStyle {
    readonly color: Color4;
    /** Note: The stroke `width` is twice the stroke radius. */
    readonly width: number;
}
interface RenderingStyle {
    readonly fill: Color4;
    readonly stroke?: StrokeStyle;
}

interface RenderablePathSpec {
    startPoint: IVec2;
    commands: PathCommand[];
    style: RenderingStyle;
    path?: Path;
}
interface RenderablePathSpecWithPath extends RenderablePathSpec {
    path: Path;
}
/** Converts a renderable path (a path with a `startPoint`, `commands`, and `style`). */
declare function pathFromRenderable(renderable: RenderablePathSpec): Path;
/**
 * Converts `path` into a format that can be rendered (by passing to a {@link Stroke} constructor
 * or directly to an {@link AbstractRenderer.drawPath}).
 */
declare function pathToRenderable(path: Path, style: RenderingStyle): RenderablePathSpecWithPath;
/**
 * @returns a Path that, when rendered, looks roughly equivalent to the given path.
 */
declare function visualEquivalent(renderablePath: RenderablePathSpec, visibleRect: Rect2): RenderablePathSpecWithPath;

declare enum EraserMode {
    PartialStroke = "partial-stroke",
    FullStroke = "full-stroke"
}
interface InitialEraserOptions {
    thickness?: number;
    mode?: EraserMode;
}
/**
 * A tool that allows a user to erase parts of an image.
 */
declare class Eraser extends BaseTool {
    private editor;
    private lastPoint;
    private isFirstEraseEvt;
    private thickness;
    private thicknessValue;
    private modeValue;
    private toRemove;
    private toAdd;
    private eraseCommands;
    private addCommands;
    constructor(editor: Editor, description: string, options?: InitialEraserOptions);
    /**
       * @returns a tool that briefly enables the eraser when a physical eraser is used.
       * This tool should be added to the tool list after the primary tools.
       */
    makeEraserSwitcherTool(): BaseTool;
    private clearPreview;
    private getSizeOnCanvas;
    private drawPreviewAt;
    /**
       * @returns the eraser rectangle in canvas coordinates.
       *
       * For now, all erasers are rectangles or points.
       */
    private getEraserRect;
    /** Erases in a line from the last point to the current. */
    private eraseTo;
    onPointerDown(event: PointerEvt): boolean;
    onPointerMove(event: PointerEvt): void;
    onPointerUp(event: PointerEvt): void;
    onGestureCancel(_event: GestureCancelEvt): void;
    onKeyPress(event: KeyPressEvent): boolean;
    /** Returns the side-length of the tip of this eraser. */
    getThickness(): number;
    /** Sets the side-length of this' tip. */
    setThickness(thickness: number): void;
    /**
       * Returns a {@link MutableReactiveValue} that can be used to watch
       * this tool's thickness.
       */
    getThicknessValue(): MutableReactiveValue<number>;
    /** @returns An object that allows switching between a full stroke and a partial stroke eraser. */
    getModeValue(): MutableReactiveValue<EraserMode>;
}

interface ComponentBuilder {
    getBBox(): Rect2;
    build(): AbstractComponent;
    preview(renderer: AbstractRenderer): void;
    /**
       * Called when the pen is stationary (or the user otherwise
       * activates autocomplete). This might attempt to fit the user's
       * drawing to a particular shape.
       *
       * The shape returned by this function may be ignored if it has
       * an empty bounding box.
       *
       * Although this returns a Promise, it should return *as fast as
       * possible*.
       */
    autocorrectShape?: () => Promise<AbstractComponent | null>;
    addPoint(point: StrokeDataPoint): void;
}
type ComponentBuilderFactory = (startPoint: StrokeDataPoint, viewport: Viewport) => ComponentBuilder;

interface PenStyle {
    readonly color: Color4;
    readonly thickness: number;
    readonly factory: ComponentBuilderFactory;
}
/**
 * A tool that allows drawing shapes and freehand lines.
 *
 * To change the type of shape drawn by the pen (e.g. to switch to the rectangle
 * pen type), see {@link setStrokeFactory}.
 */
declare class Pen extends BaseTool {
    private editor;
    protected builder: ComponentBuilder | null;
    private lastPoint;
    private startPoint;
    private currentDeviceType;
    private currentPointerId;
    private styleValue;
    private style;
    private shapeAutocompletionEnabled;
    private pressureSensitivityEnabled;
    private autocorrectedShape;
    private lastAutocorrectedShape;
    private removedAutocorrectedShapeTime;
    private stationaryDetector;
    constructor(editor: Editor, description: string, style: Partial<PenStyle>);
    private getPressureMultiplier;
    protected toStrokePoint(pointer: Pointer): StrokeDataPoint;
    setPressureSensitivityEnabled(enabled: boolean): void;
    getPressureSensitivityEnabled(): boolean;
    protected previewStroke(): void;
    protected addPointToStroke(point: StrokeDataPoint): void;
    onPointerDown(event: PointerEvt): boolean;
    private eventCanCancelStroke;
    eventCanBeDeliveredToNonActiveTool(event: PointerEvt): boolean;
    onPointerMove({ current }: PointerEvt): void;
    onPointerUp({ current }: PointerEvt): boolean;
    onGestureCancel(): void;
    private removedAutocorrectedShapeRecently;
    private autocorrectShape;
    private finalizeStroke;
    private noteUpdated;
    setColor(color: Color4): void;
    setThickness(thickness: number): void;
    /**
       * Changes the type of stroke created by the pen. The given `factory` can be one of the built-in
       * stroke factories (e.g. {@link makeFreehandLineBuilder}) or a custom stroke factory.
       *
       * Example:
       * [[include:doc-pages/inline-examples/changing-pen-types.md]]
       */
    setStrokeFactory(factory: ComponentBuilderFactory): void;
    setHasStabilization(hasStabilization: boolean): void;
    setStrokeAutocorrectEnabled(enabled: boolean): void;
    getStrokeAutocorrectionEnabled(): boolean;
    getThickness(): number;
    getColor(): Color4;
    getStrokeFactory(): ComponentBuilderFactory;
    getStyleValue(): MutableReactiveValue<PenStyle>;
    onKeyPress(event: KeyPressEvent): boolean;
}

declare enum SelectionMode {
    Lasso = "lasso",
    Rectangle = "rect"
}

type IconElemType = HTMLImageElement | SVGElement;
/**
 * Provides icons that can be used in the toolbar and other locations.
 *
 * To customize the icons used by the editor, extend this class and override methods.
 *
 * @example
 * ```ts,runnable
 * import * as easydraw from 'easydrawer';
 *
 * class CustomIconProvider extends easydraw.IconProvider {
 *     // Use '☺' instead of the default dropdown symbol.
 *     public override makeDropdownIcon() {
 *         const icon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
 *         icon.innerHTML = `
 *             <text x='5' y='55' style='fill: var(--icon-color); font-size: 50pt;'>☺</text>
 *         `;
 *         icon.setAttribute('viewBox', '0 0 100 100');
 *         return icon;
 *     }
 * }
 *
 * const icons = new CustomIconProvider();
 * const editor = new easydraw.Editor(document.body, {
 *     // The icon pack to use is specified through the editor's initial
 *     // configuration object:
 *     iconProvider: icons,
 * });
 *
 * // Add a toolbar that uses these icons
 * easydraw.makeDropdownToolbar(editor).addDefaults();
 * ```
 */
declare class IconProvider {
    #private;
    makeUndoIcon(): IconElemType;
    makeRedoIcon(): IconElemType;
    makeDropdownIcon(): IconElemType;
    makeEraserIcon(eraserSize?: number, mode?: EraserMode): IconElemType;
    makeSelectionIcon(mode?: SelectionMode): IconElemType;
    makeRotateIcon(): IconElemType;
    makeHandToolIcon(): IconElemType;
    makeTouchPanningIcon(): IconElemType;
    /** Unused by easydraw. @deprecated */
    makeAllDevicePanningIcon(): IconElemType;
    makeZoomIcon(): IconElemType;
    makeRotationLockIcon(): IconElemType;
    makeInsertImageIcon(): IconElemType;
    makeUploadFileIcon(): IconElemType;
    makeTextIcon(textStyle: TextRenderingStyle): IconElemType;
    makePenIcon(penStyle: PenStyle): IconElemType;
    makeIconFromFactory(penStyle: PenStyle): IconElemType;
    makePipetteIcon(color?: Color4): IconElemType;
    makeShapeAutocorrectIcon(): IconElemType;
    makeStrokeSmoothingIcon(): IconElemType;
    /** Unused. @deprecated */
    makeFormatSelectionIcon(): IconElemType;
    makeResizeImageToSelectionIcon(): IconElemType;
    /** Renamed to {@link makeResizeImageToSelectionIcon} @deprecated */
    makeResizeViewportIcon(): IconElemType;
    makeDuplicateSelectionIcon(): IconElemType;
    makeCopyIcon(): IconElemType;
    makePasteIcon(): IconElemType;
    makeDeleteSelectionIcon(): IconElemType;
    makeCloseIcon(): IconElemType;
    makeSaveIcon(): IconElemType;
    makeConfigureDocumentIcon(): IconElemType;
    makeOverflowIcon(): IconElemType;
    makeHelpIcon(): IconElemType;
    /**
       * @param pathData - SVG path data (e.g. `m10,10l30,30z`)
       * @param fill - A valid CSS color (e.g. `var(--icon-color)` or `#f0f`). This can be `none`.
       */
    protected makeIconFromPath(pathData: string, fill?: string, strokeColor?: string, strokeWidth?: string): IconElemType;
    /**
       * @returns An object with both the definition of a checkerboard pattern and the syntax to
       * reference that pattern. The defs provided by this function should be wrapped within a
       * `<defs></defs>` element.
       *
       * **Note**: This function's return value includes both `patternDefElement` (which returns
       * an Element) and a (deprecated) `patternDef` string. Avoid using the `patternDef` result.
       */
    protected makeCheckerboardPattern(): {
        patternDefElement: SVGElement;
        readonly patternDef: string;
        patternRef: string;
    };
    /**
       * @returns true if the given `penStyle` is known to match a rounded tip type of pen.
       */
    protected isRoundedTipPen(penStyle: PenStyle): boolean;
    protected isPolylinePen(penStyle: PenStyle): boolean;
    /** Must be overridden by icon packs that need attribution. */
    licenseInfo(): string | null;
}

interface ActionButtonIcon {
    icon: Element;
    label: string;
}
interface ToolbarContext {
    announceForAccessibility(text: string): void;
    localization: ToolbarLocalization;
    icons: IconProvider;
}

/**
 * Creates and manages an overlay that shows help text for a set of
 * `HTMLElement`s.
 *
 * @see {@link BaseWidget.fillDropdown}.
 */
declare class HelpDisplay {
    #private;
    private createOverlay;
    private context;
    /** Constructed internally by BaseWidget. @internal */
    constructor(createOverlay: (htmlElement: HTMLElement) => void, context: ToolbarContext);
    /** @internal */
    showHelpOverlay(): void;
    /** Marks `helpText` as associated with a single `targetElement`. */
    registerTextHelpForElement(targetElement: HTMLElement, helpText: string): void;
    /** Marks `helpText` as associated with all elements in `targetElements`. */
    registerTextHelpForElements(targetElements: HTMLElement[], helpText: string): void;
    /** Returns true if any help text has been registered. */
    hasHelpText(): boolean;
    /**
       * Creates and returns a button that toggles the help display.
       */
    createToggleButton(): HTMLElement;
}

type SavedToolbuttonState = Record<string, any>;
/**
 * A set of labels that allow toolbar themes to treat buttons differently.
 */
declare enum ToolbarWidgetTag {
    Save = "save",
    Exit = "exit",
    Undo = "undo",
    Redo = "redo"
}
/**
 * The `abstract` base class for items that can be shown in a `easydrawer` toolbar. See also {@link AbstractToolbar.addWidget}.
 *
 * See [the custom tool example](https://github.com/personalizedrefrigerator/easydrawer/blob/main/docs/examples/example-custom-tools/example.ts)
 * for how to create a custom toolbar widget for a tool.
 *
 * For custom action buttons, {@link AbstractToolbar.addActionButton} may be sufficient for most use cases.
 */
declare abstract class BaseWidget {
    #private;
    protected editor: Editor;
    protected id: string;
    protected readonly container: HTMLElement;
    private button;
    private icon;
    private layoutManager;
    private dropdown;
    private dropdownContent;
    private dropdownIcon;
    private label;
    private disabled;
    private subWidgets;
    private toplevel;
    protected readonly localizationTable: ToolbarLocalization;
    constructor(editor: Editor, id: string, localizationTable?: ToolbarLocalization);
    /**
       * Should return a constant true or false value. If true (the default),
       * this widget must be automatically disabled when its editor is read-only.
       */
    protected shouldAutoDisableInReadOnlyEditor(): boolean;
    getId(): string;
    /**
       * Note: Tags should be set *before* a tool widget is added to a toolbar.
       *
       *
       * Associates tags with this widget that can be used by toolbar themes
       * to customize the layout/appearance of this button. Prefer tags in
       * the `ToolbarWidgetTag` enum, where possible.
       *
       * In addition to being readable from the {@link getTags} method, tags are
       * added to a button's main container as CSS classes with the `toolwidget-tag--` prefix.
       *
       * For example, the `undo` tag would result in `toolwidget-tag--undo`
       * being added to the button's container's class list.
       *
       */
    setTags(tags: (string | ToolbarWidgetTag)[]): void;
    getTags(): string[];
    /**
       * Returns the ID of this widget in `container`. Adds a suffix to this' ID
       * if an item in `container` already has this' ID.
       *
       * For example, if `this` has ID `foo` and if
       * `container = { 'foo': somethingNotThis, 'foo-1': somethingElseNotThis }`, this method
       * returns `foo-2` because elements with IDs `foo` and `foo-1` are already present in
       * `container`.
       *
       * If `this` is already in `container`, returns the id given to `this` in the container.
       */
    getUniqueIdIn(container: Record<string, BaseWidget>): string;
    protected abstract getTitle(): string;
    protected abstract createIcon(): Element | null;
    protected fillDropdown(dropdown: HTMLElement, helpDisplay?: HelpDisplay): boolean;
    /**
       * Should return a 1-2 sentence description of the widget.
       *
       * At present, this is only used if this widget has an associated dropdown.
       */
    protected getHelpText(): undefined | string;
    /** @deprecated Renamed to `setUpButtonEventListeners`. */
    protected setupActionBtnClickListener(button: HTMLElement): void;
    protected setUpButtonEventListeners(button: HTMLElement): void;
    protected onKeyPress(_event: KeyPressEvent): boolean;
    protected abstract handleClick(): void;
    protected get hasDropdown(): boolean;
    protected addSubWidget(widget: BaseWidget): void;
    setLayoutManager(manager: WidgetContentLayoutManager): void;
    /**
       * Adds this to `parent`.
       * Returns the element that was just added to `parent`.
       * @internal
       */
    addTo(parent: HTMLElement): HTMLElement;
    /**
       * Remove this. This allows the widget to be added to a toolbar again
       * in the future using `addTo`.
       */
    remove(): void;
    focus(): void;
    /**
       * @internal
       */
    addCSSClassToContainer(className: string): void;
    removeCSSClassFromContainer(className: string): void;
    protected updateIcon(): void;
    setDisabled(disabled: boolean): void;
    setSelected(selected: boolean): void;
    protected setDropdownVisible(visible: boolean): void;
    /**
       * Only used by some layout managers.
       * In those layout managers, makes this dropdown visible.
       */
    protected activateDropdown(): void;
    /**
       * Returns `true` if this widget must always be in a toplevel menu and not
       * in a scrolling/overflow menu.
       *
       * This method can be overidden to override the default of `true`.
       */
    mustBeInToplevelMenu(): boolean;
    /**
       * Returns true iff this widget can be in a nontoplevel menu.
       *
       * @deprecated Use `!mustBeInToplevelMenu()` instead.
       */
    canBeInOverflowMenu(): boolean;
    getButtonWidth(): number;
    isHidden(): boolean;
    setHidden(hidden: boolean): void;
    /** Set whether the widget is contained within another. @internal */
    setIsToplevel(toplevel: boolean): void;
    /** Returns true if the menu for this widget is open. */
    protected isDropdownVisible(): boolean;
    protected isSelected(): boolean;
    private createDropdownIcon;
    /**
       * Serialize state associated with this widget.
       * Override this method to allow saving/restoring from state on application load.
       *
       * Overriders should call `super` and include the output of `super.serializeState` in
       * the output dictionary.
       *
       * Clients should not rely on the output from `saveState` being in any particular
       * format.
       */
    serializeState(): SavedToolbuttonState;
    /**
       * Restore widget state from serialized data. See also `saveState`.
       *
       * Overriders must call `super`.
       */
    deserializeFrom(state: SavedToolbuttonState): void;
}

interface SpacerOptions {
    grow: number;
    minSize: string;
    maxSize: string;
}
type ToolbarActionButtonOptions = {
    mustBeToplevel?: boolean;
    autoDisableInReadOnlyEditors?: boolean;
};
/**
 * Abstract base class for easydrawer editor toolbars.
 *
 * See {@link Editor.addToolbar}, {@link makeDropdownToolbar}, and {@link makeEdgeToolbar}.
 */
declare abstract class AbstractToolbar {
    #private;
    protected editor: Editor;
    widgetList: Array<BaseWidget>;
    private static colorisStarted;
    protected localizationTable: ToolbarLocalization;
    /** @internal */
    constructor(editor: Editor, localizationTable: ToolbarLocalization);
    private closeColorPickerOverlay;
    private setupCloseColorPickerOverlay;
    setupColorPickers(): void;
    protected closeColorPickers(): void;
    protected getWidgetUniqueId(widget: BaseWidget): string;
    protected getWidgetFromId(id: string): BaseWidget | undefined;
    /** Do **not** modify the return value. */
    getAllWidgets(): Array<BaseWidget>;
    /**
       * Adds a spacer.
       *
       * **Toolbars can choose to ignore calls to `addSpacer`**.
       *
       * @example
       * Adding a save button that moves to the very right edge of the toolbar
       * while keeping the other buttons centered:
       * ```ts
       * const toolbar = editor.addToolbar(false);
       *
       * toolbar.addSpacer({ grow: 1 });
       * toolbar.addDefaults();
       * toolbar.addSpacer({ grow: 1 });
       *
       * toolbar.addActionButton({
       * 	label: 'Save',
       * 	icon: editor.icons.makeSaveIcon(),
       * }, () => {
       * 	  saveCallback();
       * });
       * ```
       */
    abstract addSpacer(options?: Partial<SpacerOptions>): void;
    /**
       * Adds an `ActionButtonWidget` or `BaseToolWidget`. The widget should not have already have a parent
       * (i.e. its `addTo` method should not have been called).
       *
       * @example
       * ```ts
       * const toolbar = editor.addToolbar();
       * const insertImageWidget = new InsertImageWidget(editor);
       * toolbar.addWidget(insertImageWidget);
       * ```
       */
    addWidget(widget: BaseWidget): void;
    /** Called by `addWidget`. Implement this to add a new widget to the toolbar. */
    protected abstract addWidgetInternal(widget: BaseWidget): void;
    /** Removes the given `widget` from this toolbar. */
    removeWidget(widget: BaseWidget): void;
    /** Called by `removeWidget`. Implement this to remove a new widget from the toolbar. */
    protected abstract removeWidgetInternal(widget: BaseWidget): void;
    private static rootToolbarId;
    /** Returns a snapshot of the state of widgets in the toolbar. */
    serializeState(): string;
    /**
       * Deserialize toolbar widgets from the given state.
       * Assumes that toolbar widgets are in the same order as when state was serialized.
       */
    deserializeState(state: string): void;
    /**
       * Called by `serializeState` to attach any additional JSONifyable data
       * to the serialized result.
       *
       * @returns an object that can be converted to JSON with `JSON.stringify`.
       */
    protected serializeInternal(): any;
    /**
       * Called by `deserializeState` with a version of the JSON outputted
       * previously by `serializeInternal`.
       */
    protected deserializeInternal(_json: any): void;
    /**
       * Creates, but does not add, an action button to this container.
       *
       * @see
       * {@link addActionButton}
       */
    protected makeActionButton(title: string | ActionButtonIcon, command: () => void, options?: ToolbarActionButtonOptions | boolean): BaseWidget;
    /**
       * Adds an action button with `title` to this toolbar (or to the given `parent` element).
       *
       * `options` can either be an object with properties `mustBeToplevel` and/or
       * `autoDisableInReadOnlyEditors` or a boolean value. If a boolean, it is interpreted
       * as being the value of `mustBeToplevel`.
       *
       * @return The added button.
       *
       * **Example**:
       * ```ts,runnable
       * import { Editor } from 'easydrawer';
       * const editor = new Editor(document.body);
       * const toolbar = editor.addToolbar();
       *
       * function makeTrashIcon() {
       *   const container = document.createElement('div');
       *   container.textContent = '🗑️';
       *   return container;
       * }
       *
       * toolbar.addActionButton({
       *   icon: makeTrashIcon(), // can be any Element not in the DOM
       *   label: 'Delete all',
       * }, () => {
       *   alert('to-do!');
       * });
       */
    addActionButton(title: string | ActionButtonIcon, command: () => void, options?: ToolbarActionButtonOptions | boolean): BaseWidget;
    /**
       * Like {@link addActionButton}, except associates `tags` with the button that allow
       * different toolbar styles to give the button tag-dependent styles.
       */
    addTaggedActionButton(tags: (ToolbarWidgetTag | string)[], title: string | ActionButtonIcon, command: () => void, options?: ToolbarActionButtonOptions | boolean): BaseWidget;
    /**
       * Adds a save button that, when clicked, calls `saveCallback`.
       *
       * @example
       * ```ts,runnable
       * import { Editor, makeDropdownToolbar } from 'easydrawer';
       *
       * const editor = new Editor(document.body);
       * const toolbar = makeDropdownToolbar(editor);
       *
       * toolbar.addDefaults();
       * toolbar.addSaveButton(() => alert('save clicked!'));
       * ```
       *
       * `labelOverride` can optionally be used to change the `label` or `icon` of the button.
       */
    addSaveButton(saveCallback: () => void, labelOverride?: Partial<ActionButtonIcon>): BaseWidget;
    /**
       * Adds an "Exit" button that, when clicked, calls `exitCallback`.
       *
       * **Note**: This is *roughly* equivalent to
       * ```ts
       * toolbar.addTaggedActionButton([ ToolbarWidgetTag.Exit ], {
       *   label: this.editor.localization.exit,
       *   icon: this.editor.icons.makeCloseIcon(),
       *
       *   // labelOverride can be used to override label or icon.
       *   ...labelOverride,
       * }, () => {
       *   exitCallback();
       * });
       * ```
       * with some additional configuration.
       *
       * @final
       */
    addExitButton(exitCallback: () => void, labelOverride?: Partial<ActionButtonIcon>): BaseWidget;
    /**
       * Adds undo and redo buttons that trigger the editor's built-in undo and redo
       * functionality.
       */
    addUndoRedoButtons(undoFirst?: boolean): void;
    /**
       * Adds widgets for pen/eraser/selection/text/pan-zoom primary tools.
       *
       * If `filter` returns `false` for a tool, no widget is added for that tool.
       * See {@link addDefaultToolWidgets}
       */
    addWidgetsForPrimaryTools(filter?: (tool: BaseTool) => boolean): void;
    /**
       * Adds toolbar widgets based on the enabled tools, and additional tool-like
       * buttons (e.g. {@link DocumentPropertiesWidget} and {@link InsertImageWidget}).
       */
    addDefaultToolWidgets(): void;
    /**
       * Adds widgets that don't correspond to tools, but do allow the user to control
       * the editor in some way.
       *
       * By default, this includes {@link DocumentPropertiesWidget} and {@link InsertImageWidget}.
       */
    addDefaultEditorControlWidgets(): void;
    addDefaultActionButtons(): void;
    /**
       * Adds both the default tool widgets and action buttons.
       */
    abstract addDefaults(): void;
    /**
       * Remove this toolbar from its container and clean up listeners.
       * This should only be called **once** for a given toolbar.
       */
    remove(): void;
    /**
       * Removes `listener` when {@link remove} is called.
       */
    protected manageListener(listener: DispatcherEventListener): void;
    /**
       * Internal logic for {@link remove}. Implementers should remove the toolbar
       * from its container.
       */
    protected abstract onRemove(): void;
}

/**
 * Return the localization table in `localizationTables` that best matches
 * the list of `userLocales`. If there is no matching language, returns
 * `defaultLocalizationTable`.
 */
declare function matchingLocalizationTable<T>(userLocales: readonly string[], localizationTables: Record<string, T>, defaultLocalizationTable: T): T;
/**
 * Returns a localization table for the `Editor` that matches
 * the user's current locale.
 *
 * Returns the default localization table if no appropriate localization
 * exists.
 */
declare function getLocalizationTable(userLocales?: readonly string[]): EditorLocalization;

interface SVGLoaderControl {
    /** Call this to add a component to the editor. */
    addComponent: ComponentAddedListener;
}
/**
 * Loads custom components from an SVG image.
 * @see SVGLoader.fromString
 */
interface SVGLoaderPlugin {
    /**
       * Called when the {@link SVGLoader} encounters a `node`.
       *
       * Call `loader.addComponent` to add new components to the image.
       *
       * Returning `true` prevents the {@link SVGLoader} from doing further
       * processing on the node.
       */
    visit(node: Element, loader: SVGLoaderControl): Promise<boolean>;
}
declare enum SVGLoaderLoadMethod {
    IFrame = "iframe",
    DOMParser = "domparser"
}
interface SVGLoaderOptions {
    sanitize?: boolean;
    disableUnknownObjectWarnings?: boolean;
    plugins?: SVGLoaderPlugin[];
    loadMethod?: SVGLoaderLoadMethod;
}
declare class SVGLoader implements ImageLoader {
    private source;
    private onFinish;
    private onAddComponent;
    private onProgress;
    private onDetermineExportRect;
    private processedCount;
    private totalToProcess;
    private rootViewBox;
    private readonly storeUnknown;
    private readonly disableUnknownObjectWarnings;
    private readonly plugins;
    private constructor();
    private getStyle;
    private strokeDataFromElem;
    private attachUnrecognisedAttrs;
    private addPath;
    private addBackground;
    private getComputedStyle;
    private getTransform;
    private makeText;
    private addText;
    private addImage;
    private addUnknownNode;
    private containerGroupIDs;
    private encounteredIDs;
    private startGroup;
    private endGroup;
    private addComponent;
    private updateViewBox;
    private updateSVGAttrs;
    private visit;
    private getSourceAttrs;
    start(onAddComponent: ComponentAddedListener, onProgress: OnProgressListener, onDetermineExportRect?: OnDetermineExportRectListener | null): Promise<void>;
    /**
       * Create an `SVGLoader` from the content of an SVG image. SVGs are loaded within a sandboxed
       * iframe with `sandbox="allow-same-origin"`
       * [thereby disabling JavaScript](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#sandbox).
       *
       * @see {@link Editor.loadFrom}
       * @param text - Textual representation of the SVG (e.g. `<svg viewbox='...'>...</svg>`).
       * @param options - if `true` or `false`, treated as the `sanitize` option -- don't store unknown attributes.
       */
    static fromString(text: string, options?: Partial<SVGLoaderOptions> | boolean): SVGLoader;
}

interface ComponentStyle {
    color?: Color4;
    textStyle?: TextRenderingStyle;
}
declare function createRestyleComponentCommand(initialStyle: ComponentStyle, newStyle: ComponentStyle, component: RestyleableComponent): SerializableCommand;
declare function isRestylableComponent(component: AbstractComponent): component is RestyleableComponent;
/**
 * An interface to be implemented by components with a changable color or {@link TextRenderingStyle}.
 *
 * All such classes must have a member variable, `isRestylableComponent` that is set to `true`
 * to allow testing whether the class is a `RestylableComponent` (see {@link isRestylableComponent}).
 */
interface RestyleableComponent extends AbstractComponent {
    /**
       * @returns a partial representation of this component's style.
       */
    getStyle(): ComponentStyle;
    /**
       * Returns a {@link Command} that updates portions of this component's style
       * to the given `style`.
       *
       * @example
       * For some component and editor,
       * ```ts
       * editor.dispatch(component.updateStyle({ color: Color4.red }));
       * ```
       */
    updateStyle(style: ComponentStyle): SerializableCommand;
    /**
       * Set the style of this component in a way that can't be undone/redone
       * (does not create a command).
       *
       * Prefer `updateStyle(style).apply(editor)`.
       */
    forceStyle(style: ComponentStyle, editor: Editor | null): void;
    isRestylableComponent: true;
}

declare enum BackgroundType {
    SolidColor = 0,
    Grid = 1,
    None = 2,
    Dot = 3
}
declare class BackgroundComponent extends AbstractComponent implements RestyleableComponent {
    private backgroundType;
    private mainColor;
    protected contentBBox: Rect2;
    private viewportSizeChangeListener;
    private autoresizeChangedListener;
    private fillsScreen;
    private gridSize;
    private gridStrokeWidth;
    private secondaryColor;
    readonly isRestylableComponent: true;
    constructor(backgroundType: BackgroundType, mainColor: Color4);
    static ofGrid(backgroundColor: Color4, gridSize?: number, gridColor?: Color4, gridStrokeWidth?: number): BackgroundComponent;
    getBackgroundType(): BackgroundType;
    getMainColor(): Color4;
    getSecondaryColor(): Color4 | null;
    getGridSize(): number;
    getStyle(): ComponentStyle;
    updateStyle(style: ComponentStyle): SerializableCommand;
    forceStyle(style: ComponentStyle, editor: Editor | null): void;
    onAddToImage(image: EditorImage): void;
    onRemoveFromImage(): void;
    private recomputeBBox;
    private generateGridPath;
    private generateDotPath;
    /**
       * @returns this background's bounding box if the screen size is taken into
       * account (which may be necessary if this component is configured to fill the
       * entire screen).
       */
    private getFullBoundingBox;
    render(canvas: AbstractRenderer, visibleRect?: Rect2): void;
    intersects(lineSegment: LineSegment2): boolean;
    isSelectable(): boolean;
    isBackground(): boolean;
    getSizingMode(): ComponentSizingMode;
    protected serializeToJSON(): {
        mainColor: string;
        secondaryColor: string | undefined;
        backgroundType: BackgroundType;
        gridSize: number;
        gridStrokeWidth: number;
    };
    protected applyTransformation(_affineTransfm: Mat33): void;
    description(localizationTable: ImageComponentLocalization): string;
    protected createClone(): AbstractComponent;
    static deserializeFromJSON(this: void, json: any): BackgroundComponent;
}

/**
 * Represents a raster image.
 *
 * **Example: Adding images**:
 * [[include:doc-pages/inline-examples/adding-an-image-and-data-urls.md]]
 */
declare class ImageComponent extends AbstractComponent {
    protected contentBBox: Rect2;
    private image;
    constructor(image: RenderableImage);
    private getImageRect;
    private recomputeBBox;
    /**
       * Load from an image. Waits for the image to load if incomplete.
       *
       * The image, `elem`, must not [taint](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image#security_and_tainted_canvases)
       * an HTMLCanvasElement when rendered.
       */
    static fromImage(elem: HTMLImageElement, transform: Mat33): Promise<ImageComponent>;
    render(canvas: AbstractRenderer, _visibleRect?: Rect2): void;
    getProportionalRenderingTime(): number;
    intersects(lineSegment: LineSegment2): boolean;
    protected applyTransformation(affineTransfm: Mat33): void;
    description(localizationTable: ImageComponentLocalization): string;
    getAltText(): string | undefined;
    getURL(): string;
    getTransformation(): Mat33;
    protected createClone(): AbstractComponent;
    protected serializeToJSON(): {
        src: string;
        label: string | undefined;
        width: number;
        height: number;
        transform: Mat33Array;
    };
    static deserializeFromJSON(this: void, data: any): ImageComponent;
}

/**
 * Represents an {@link AbstractComponent} made up of one or more {@link Path}s.
 *
 * @example
 * For some {@link Editor} editor and `Stroke` stroke,
 *
 * **Restyling**:
 * ```ts
 * editor.dispatch(stroke.updateStyle({ color: Color4.red }));
 * ```
 *
 * **Transforming**:
 * ```ts
 * editor.dispatch(stroke.transformBy(Mat33.translation(Vec2.of(10, 0))));
 * ```
 *
 * **Adding**:
 * [[include:doc-pages/inline-examples/adding-a-stroke.md]]
 */
declare class Stroke extends AbstractComponent implements RestyleableComponent {
    private parts;
    protected contentBBox: Rect2;
    readonly isRestylableComponent: true;
    private approximateRenderingTime;
    /**
       * Creates a `Stroke` from the given `parts`. All parts should have the
       * same color.
       *
       * @example
       * ```ts
       * // A path that starts at (1,1), moves to the right by (2, 0),
       * // then moves down and right by (3, 3)
       * const path = Path.fromString('m1,1 2,0 3,3');
       *
       * const stroke = new Stroke([
       *     // Fill with red
       *     pathToRenderable(path, { fill: Color4.red })
       * ]);
       * ```
       */
    constructor(parts: RenderablePathSpec[], initialZIndex?: number);
    /**
       * Creates a new `Stroke` from a {@link Path} and `style`. Strokes created
       * with this method have transparent fill.
       *
       * Example:
       * ```ts,runnable
       * import { Editor, Stroke, Color4 } from 'easydrawer';
       * const editor = new Editor(document.body);
       * ---visible---
       * const stroke = Stroke.fromStroked('m0,0 l10,10', { width: 10, color: Color4.red });
       * editor.dispatch(editor.image.addComponent(stroke));
       * ```
       * Notice that `path` can be a string that specifies an SVG path
       *
       * @see fromFilled
       */
    static fromStroked(path: Path | string, style: StrokeStyle): Stroke;
    /** @see fromStroked */
    static fromFilled(path: Path | string, fill: Color4): Stroke;
    getStyle(): ComponentStyle;
    updateStyle(style: ComponentStyle): SerializableCommand;
    forceStyle(style: ComponentStyle, editor: Editor | null): void;
    /** @beta -- May fail for concave `path`s */
    withRegionErased(eraserPath: Path, viewport: Viewport): Stroke[];
    intersects(line: LineSegment2): boolean;
    keyPoints(): IVec2[];
    intersectsRect(rect: Rect2): boolean;
    private simplifiedPath;
    private computeSimplifiedPathFor;
    occludesEverythingBelowWhenRenderedInRect(rect: Rect2): boolean;
    render(canvas: AbstractRenderer, visibleRect?: Rect2): void;
    getProportionalRenderingTime(): number;
    private bboxForPart;
    getExactBBox(): Rect2;
    protected applyTransformation(affineTransfm: Mat33): void;
    /**
       * @returns A list of the parts that make up this path. Many paths only have one part.
       *
       * Each part (a {@link RenderablePathSpec}) contains information about the style and geometry
       * of that part of the stroke. Use the `.path` property to do collision detection and other
       * operations involving the stroke's geometry.
       *
       * Note that many of {@link Path}'s methods (e.g. {@link Path.intersection}) take a
       * `strokeWidth` parameter that can be gotten from {@link RenderablePathSpec.style} `.stroke.width`.
       */
    getParts(): Readonly<RenderablePathSpecWithPath>[];
    /**
       * @returns the {@link Path.union} of all paths that make up this stroke.
       */
    getPath(): Path;
    description(localization: ImageComponentLocalization): string;
    protected createClone(): AbstractComponent;
    protected serializeToJSON(): {
        style: {
            fill: string;
            stroke: {
                color: string;
                width: number;
            } | undefined;
        };
        path: string;
    }[];
    /** @internal */
    static deserializeFromJSON(this: void, json: any): Stroke;
}

declare enum TextTransformMode {
    /** Absolutely positioned in both the X and Y dimensions. */
    ABSOLUTE_XY = 0,
    /** Relatively positioned in both the X and Y dimensions. */
    RELATIVE_XY = 1,
    /**Relatively positioned in the X direction, absolutely positioned in the Y direction. */
    RELATIVE_X_ABSOLUTE_Y = 2,
    /**Relatively positioned in the Y direction, absolutely positioned in the X direction. */
    RELATIVE_Y_ABSOLUTE_X = 3
}
type TextElement = TextComponent | string;
/**
 * Displays text.
 *
 * A `TextComponent` is a collection of `TextElement`s (`string`s or {@link TextComponent}s).
 *
 * **Example**:
 *
 * ```ts,runnable
 * import { Editor, TextComponent, Mat33, Vec2, Color4, TextRenderingStyle } from 'easydrawer';
 * const editor = new Editor(document.body);
 * editor.dispatch(editor.setBackgroundStyle({ color: Color4.black, autoresize: true ));
 * ---visible---
 * /// Adding a simple TextComponent
 * ///------------------------------
 *
 * const positioning1 = Mat33.translation(Vec2.of(10, 10));
 * const style: TextRenderingStyle = {
 *     fontFamily: 'sans', size: 12, renderingStyle: { fill: Color4.green },
 * };
 *
 * editor.dispatch(
 *     editor.image.addComponent(new TextComponent(['Hello, world'], positioning1, style)),
 * );
 *
 *
 * /// Adding nested TextComponents
 * ///-----------------------------
 *
 * // Add another TextComponent that contains text and a TextComponent. Observe that '[Test]'
 * // is placed directly after 'Test'.
 * const positioning2 = Mat33.translation(Vec2.of(10, 50));
 * editor.dispatch(
 *     editor.image.addComponent(
 *         new TextComponent([ new TextComponent(['Test'], positioning1, style), '[Test]' ], positioning2, style)
 *     ),
 * );
 * ```
 */
declare class TextComponent extends AbstractComponent implements RestyleableComponent {
    protected readonly textObjects: Array<TextElement>;
    private transform;
    private style;
    private transformMode;
    protected contentBBox: Rect2;
    readonly isRestylableComponent: true;
    /**
       * Creates a new text object from a list of component text or child TextComponents.
       *
       * @see {@link fromLines}
       */
    constructor(textObjects: Array<TextElement>, transform: Mat33, style?: TextRenderingStyle, transformMode?: TextTransformMode);
    static applyTextStyles(ctx: CanvasRenderingContext2D, style: TextRenderingStyle): void;
    private static textMeasuringCtx;
    private static estimateTextDimens;
    private static getTextMetrics;
    private static getTextDimens;
    private static getFontHeight;
    private computeUntransformedBBoxOfPart;
    private recomputeBBox;
    /**
       * Renders a TextComponent or a TextComponent child onto a `canvas`.
       *
       * `visibleRect` can be provided as a performance optimization. If not the top-level
       * text node, `baseTransform` (specifies the transformation of the parent text component
       * in canvas space) should also be provided.
       *
       * Note that passing a `baseTransform` is preferable to transforming `visibleRect`. At high
       * zoom levels, transforming `visibleRect` by the inverse of the parent transform can lead to
       * inaccuracy due to precision loss.
       */
    private renderInternal;
    render(canvas: AbstractRenderer, visibleRect?: Rect2): void;
    getProportionalRenderingTime(): number;
    intersects(lineSegment: LineSegment2): boolean;
    getStyle(): ComponentStyle;
    updateStyle(style: ComponentStyle): SerializableCommand;
    forceStyle(style: ComponentStyle, editor: Editor | null): void;
    getTextStyle(): TextRenderingStyle;
    getBaselinePos(): IVec2;
    getTransform(): Mat33;
    protected applyTransformation(affineTransfm: Mat33): void;
    protected createClone(): AbstractComponent;
    getText(): string;
    description(localizationTable: ImageComponentLocalization): string;
    protected serializeToJSON(): Record<string, any>;
    static deserializeFromString(json: any): TextComponent;
    /**
       * Creates a `TextComponent` from `lines`.
       *
       * @example
       * ```ts
       * const textStyle = {
       *   size: 12,
       *   fontFamily: 'serif',
       *   renderingStyle: { fill: Color4.black },
       * };
       *
       * const text = TextComponent.fromLines('foo\nbar'.split('\n'), Mat33.identity, textStyle);
       * ```
       */
    static fromLines(lines: string[], transform: Mat33, style: TextRenderingStyle): AbstractComponent;
    private static TextCursor;
}

/**
 * Creates a stroke builder that draws freehand lines.
 *
 * Example:
 * [[include:doc-pages/inline-examples/changing-pen-types.md]]
 */
declare const makeFreehandLineBuilder: ComponentBuilderFactory;

/**
 * Creates a freehand line builder that creates strokes from line segments
 * rather than Bézier curves.
 *
 * Example:
 * [[include:doc-pages/inline-examples/changing-pen-types.md]]
 */
declare const makePolylineBuilder: ComponentBuilderFactory;

declare const makePressureSensitiveFreehandLineBuilder: ComponentBuilderFactory;

/**
 * Creates a stroke builder that generates outlined circles.
 *
 * Example:
 * [[include:doc-pages/inline-examples/changing-pen-types.md]]
 */
declare const makeCircleBuilder: ComponentBuilderFactory;

/**
 * Creates a stroke builder that generates arrows.
 *
 * Example:
 * [[include:doc-pages/inline-examples/changing-pen-types.md]]
 */
declare const makeArrowBuilder: ComponentBuilderFactory;

/**
 * Creates a stroke builder that generates filled lines.
 *
 * Example:
 * [[include:doc-pages/inline-examples/changing-pen-types.md]]
 */
declare const makeLineBuilder: ComponentBuilderFactory;

/**
 * Creates filled rectangles with sharp corners.
 *
 * Example:
 * [[include:doc-pages/inline-examples/changing-pen-types.md]]
 */
declare const makeFilledRectangleBuilder: ComponentBuilderFactory;
/**
 * Creates outlined rectangles with sharp corners.
 *
 * Example:
 * [[include:doc-pages/inline-examples/changing-pen-types.md]]
 */
declare const makeOutlinedRectangleBuilder: ComponentBuilderFactory;

interface Curve {
    startPoint: IVec2;
    startWidth: number;
    controlPoint: IVec2;
    endWidth: number;
    endPoint: IVec2;
}
type OnCurveAddedCallback = (curve: Curve | null) => void;
declare class StrokeSmoother {
    private startPoint;
    private minFitAllowed;
    private maxFitAllowed;
    private onCurveAdded;
    private isFirstSegment;
    private buffer;
    private lastPoint;
    private lastExitingVec;
    private currentCurve;
    private curveStartWidth;
    private curveEndWidth;
    private momentum;
    private bbox;
    constructor(startPoint: StrokeDataPoint, minFitAllowed: number, maxFitAllowed: number, onCurveAdded: OnCurveAddedCallback);
    getBBox(): Rect2;
    preview(): Curve | null;
    private approxCurrentCurveLength;
    finalizeCurrentCurve(): void;
    private currentSegmentToPath;
    private computeExitingVec;
    addPoint(newPoint: StrokeDataPoint): void;
}

/**
 * A command that duplicates the {@link AbstractComponent}s it's given. This command
 * is the reverse of an {@link Erase} command.
 *
 * @example
 * ```ts
 * // Given some editor...
 *
 * // Find all elements intersecting the rectangle with top left (0,0) and
 * // (width,height)=(100,100).
 * const elems = editor.image.getComponentsIntersecting(
 * 	new Rect2(0, 0, 100, 100)
 * );
 *
 * // Create a command that, when applied, will duplicate the elements.
 * const duplicateElems = new Duplicate(elems);
 *
 * // Apply the command (and make it undoable)
 * editor.dispatch(duplicateElems);
 * ```
 *
 * @see {@link Editor.dispatch} {@link EditorImage.getComponentsIntersecting}
 */
declare class Duplicate extends SerializableCommand {
    private toDuplicate;
    private duplicates;
    private reverse;
    constructor(toDuplicate: AbstractComponent[], idsForDuplicates?: string[]);
    apply(editor: Editor): void;
    unapply(editor: Editor): void;
    onDrop(editor: Editor): void;
    description(_editor: Editor, localizationTable: EditorLocalization): string;
    protected serializeToJSON(): {
        originalIds: string[];
        cloneIds: string[];
    };
}

/**
 * Removes the given {@link AbstractComponent}s from the image.
 *
 * **Example**:
 * ```ts,runnable
 * import { Editor, Erase, uniteCommands, Color4, Path, Stroke, Rect2, pathToRenderable } from 'easydrawer';
 *
 * const editor = new Editor(document.body);
 * editor.addToolbar();
 *
 * // Add a large number of strokes
 * const commands = [];
 * for (let x = -20; x < 20; x++) {
 *   for (let y = 0; y < 60; y++) {
 *     const stroke = new Stroke([
 *       pathToRenderable(
 *         Path.fromString(`m${x * 5},${y * 5}l1,1`),
 *         { fill: Color4.transparent, stroke: {width: 2, color: Color4.ofRGB(x / 10, y / 10, 0.5)}} )
 *       ]);
 *     commands.push(editor.image.addElement(stroke));
 *   }
 * }
 * await editor.dispatch(uniteCommands(commands, 100));
 *
 * ---visible---
 * // Given some editor...
 *
 * // Find all elements intersecting the rectangle with top left (-10,-30) and
 * // (width,height)=(50,100).
 * const elems = editor.image.getComponentsIntersecting(
 * 	new Rect2(-10, -30, 50, 100)
 * );
 *
 * // Create a command that erases [elems] when applied
 * const eraseElemsCmd = new Erase(elems);
 *
 * // Apply the command (and make it undoable)
 * editor.dispatch(eraseElemsCmd);
 * ```
 */
declare class Erase extends SerializableCommand {
    private toRemove;
    private applied;
    constructor(toRemove: AbstractComponent[]);
    apply(editor: Editor): void;
    unapply(editor: Editor): void;
    onDrop(editor: Editor): void;
    description(_editor: Editor, localizationTable: EditorLocalization): string;
    protected serializeToJSON(): {
        name: string;
        zIndex: number;
        id: string;
        loadSaveData: LoadSaveDataTable;
        data: string | number | any[] | Record<string, any>;
    }[];
}

declare function invertCommand<T extends Command>(command: T): T extends SerializableCommand ? SerializableCommand : Command;

interface UniteCommandsOptions {
    applyChunkSize?: number;
    description?: string;
}
/**
 * Creates a single command from `commands`. This is useful when undoing should undo *all* commands
 * in `commands` at once, rather than one at a time.
 *
 * @example
 *
 * ```ts,runnable
 * import { Editor, pathToRenderable, Stroke, uniteCommands } from 'easydrawer';
 * import { Path, Color4 } from '~/math/lib';
 *
 * const editor = new Editor(document.body);
 * editor.addToolbar();
 *
 * // Create strokes!
 * const strokes = [];
 * for (let i = 0; i < 10; i++) {
 *   const renderablePath = pathToRenderable(
 *     Path.fromString(`M0,${i * 10} L100,100 L300,30 z`),
 *     { fill: Color4.transparent, stroke: { color: Color4.red, width: 1, } }
 *   );
 *   strokes.push(new Stroke([ renderablePath ]));
 * }
 *
 * // Convert to commands
 * const addStrokesCommands = strokes.map(stroke => editor.image.addElement(stroke));
 *
 * // Apply all as a single undoable command (try applying each in a loop instead!)
 * await editor.dispatch(uniteCommands(addStrokesCommands));
 *
 * // The second parameter to uniteCommands is for very large numbers of commands, when
 * // applying them shouldn't be done all at once (which would block the UI).
 *
 * // The second parameter to uniteCommands is for very large numbers of commands, when
 * // applying them shouldn't be done all at once (which would block the UI).
 * ```
 */
declare function uniteCommands<T extends Command>(commands: T[], options?: UniteCommandsOptions | number): T extends SerializableCommand ? SerializableCommand : Command;

declare class ToolController implements InputEventListener {
    private tools;
    private activeTool;
    private primaryToolGroup;
    private inputPipeline;
    private isEditorReadOnly;
    /** @internal */
    constructor(editor: Editor, localization: ToolLocalization);
    /**
       * Replaces the current set of tools with `tools`. This should only be done before
       * the creation of the app's toolbar (if using `AbstractToolbar`).
       *
       * If no `primaryToolGroup` is given, an empty one will be created.
       */
    setTools(tools: BaseTool[], primaryToolGroup?: ToolEnabledGroup): void;
    /**
       * Add a tool that acts like one of the primary tools (only one primary tool can be enabled at a time).
       *
       * If the tool is already added to this, the tool is converted to a primary tool.
       *
       * This should be called before creating the app's toolbar.
       */
    addPrimaryTool(tool: BaseTool): void;
    getPrimaryTools(): BaseTool[];
    setToolEnabled(tool: BaseTool): void;
    /**
       * Add a tool to the end of this' tool list (the added tool receives events after tools already added to this).
       * This should be called before creating the app's toolbar.
       *
       * If `options.addToFront`, the tool is added to the beginning of this' tool list.
       *
       * Does nothing if the tool is already present.
       */
    addTool(tool: BaseTool, options?: {
        addToFront: boolean;
    }): void;
    /**
       * Removes **and destroys** all tools in `tools` from this.
       */
    removeAndDestroyTools(tools: BaseTool[]): void;
    private insertTools;
    /**
       * Removes a tool from this' tool list and replaces it with `replaceWith`.
       *
       * If any of `toolsToInsert` have already been added to this, the tools are
       * moved.
       *
       * This should be called before creating the editor's toolbar.
       */
    insertToolsAfter(insertAfter: BaseTool, toolsToInsert: BaseTool[]): void;
    /** @see {@link insertToolsAfter} */
    insertToolsBefore(insertBefore: BaseTool, toolsToInsert: BaseTool[]): void;
    private onEventInternal;
    /** Alias for {@link dispatchInputEvent}. */
    onEvent(event: InputEvt): boolean;
    dispatchInputEvent(event: InputEvt): boolean;
    /**
       * Adds a new `InputMapper` to this' input pipeline.
       *
       * A `mapper` is really a relation that maps each event to no, one,
       * or many other events.
       *
       * @see {@link InputMapper}.
       */
    addInputMapper(mapper: InputMapper): void;
    getMatchingTools<Type extends BaseTool>(type: new (...args: any[]) => Type): Type[];
    onEditorDestroyed(): void;
}

declare class UndoRedoShortcut extends BaseTool {
    private editor;
    constructor(editor: Editor);
    onKeyPress(event: KeyPressEvent): boolean;
}

/**
 * Handles keyboard events used, by default, to select tools. By default,
 * 1 maps to the first primary tool, 2 to the second primary tool, ... .
 *
 * This is in the default set of {@link ToolController} tools.
 *
 */
declare class ToolSwitcherShortcut extends BaseTool {
    private editor;
    constructor(editor: Editor);
    canReceiveInputInReadOnlyEditor(): boolean;
    onKeyPress({ key }: KeyPressEvent): boolean;
}

interface PinchData {
    canvasCenter: IVec2;
    screenCenter: IVec2;
    angle: number;
    dist: number;
}
declare enum PanZoomMode {
    /** Touch gestures with a single pointer. Ignores non-touch gestures. */
    OneFingerTouchGestures = 1,
    /** Touch gestures with exactly two pointers. Ignores non-touch gestures. */
    TwoFingerTouchGestures = 2,
    RightClickDrags = 4,
    /** Single-pointer gestures of *any* type (including touch). */
    SinglePointerGestures = 8,
    /** Keyboard navigation (e.g. LeftArrow to move left). */
    Keyboard = 16,
    /** If provided, prevents **this** tool from rotating the viewport (other tools may still do so). */
    RotationLocked = 32
}
/**
 * This tool moves the viewport in response to touchpad, touchscreen, mouse, and keyboard events.
 *
 * Which events are handled, and which are skipped, are determined by the tool's `mode`. For example,
 * a `PanZoom` tool with `mode = PanZoomMode.TwoFingerTouchGestures|PanZoomMode.RightClickDrags` would
 * respond to right-click drag events and two-finger touch gestures.
 *
 * @see {@link setModeEnabled}
 */
declare class PanZoom extends BaseTool {
    private editor;
    private mode;
    private transform;
    private readonly initialRotationSnapAngle;
    private readonly afterRotationStartSnapAngle;
    private readonly pinchZoomStartThreshold;
    private startTouchDist;
    private lastTouchDist;
    private lastScreenCenter;
    private lastTimestamp;
    private lastPointerDownTimestamp;
    private initialTouchAngle;
    private initialViewportRotation;
    private initialViewportScale;
    private isScaling;
    private isRotating;
    private inertialScroller;
    private velocity;
    constructor(editor: Editor, mode: PanZoomMode, description: string);
    canReceiveInputInReadOnlyEditor(): boolean;
    computePinchData(p1: Pointer, p2: Pointer): PinchData;
    private allPointersAreOfType;
    onPointerDown({ allPointers: pointers, current: currentPointer, }: PointerEvt): boolean;
    private updateVelocity;
    private getCenterDelta;
    private toSnappedRotationDelta;
    /**
       * Given a scale update, `scaleFactor`, returns a new scale factor snapped
       * to a power of two (if within some tolerance of that scale).
       */
    private toSnappedScaleFactor;
    private handleTwoFingerMove;
    private handleOneFingerMove;
    onPointerMove({ allPointers }: PointerEvt): void;
    onPointerUp(event: PointerEvt): void;
    onGestureCancel(): void;
    private updateTransform;
    /**
       * Updates the current transform and clears it. Use this method for events that are not part of
       * a larger gesture (i.e. have no start and end event). For example, this would be used for `onwheel`
       * events, but not for `onpointer` events.
       */
    private applyAndFinalizeTransform;
    onWheel({ delta, screenPos }: WheelEvt): boolean;
    onKeyPress(event: KeyPressEvent): boolean;
    private isRotationLocked;
    /**
       * Changes the types of gestures used by this pan/zoom tool.
       *
       * @see {@link PanZoomMode} {@link setMode}
       *
       * @example
       * ```ts,runnable
       * import { Editor, PanZoomTool, PanZoomMode } from 'easydrawer';
       *
       * const editor = new Editor(document.body);
       *
       * // By default, there are multiple PanZoom tools that handle different events.
       * // This gets all PanZoomTools.
       * const panZoomToolList = editor.toolController.getMatchingTools(PanZoomTool);
       *
       * // The first PanZoomTool is the highest priority -- by default,
       * // this tool is responsible for handling multi-finger touch gestures.
       * //
       * // Lower-priority PanZoomTools handle one-finger touch gestures and
       * // key-presses.
       * const panZoomTool = panZoomToolList[0];
       *
       * // Lock rotation for multi-finger touch gestures.
       * panZoomTool.setModeEnabled(PanZoomMode.RotationLocked, true);
       * ```
       */
    setModeEnabled(mode: PanZoomMode, enabled: boolean): void;
    /**
       * Sets all modes for this tool using a bitmask.
       *
       * @see {@link setModeEnabled}
       *
       * @example
       * ```ts
       * tool.setMode(PanZoomMode.RotationLocked|PanZoomMode.TwoFingerTouchGestures);
       * ```
       */
    setMode(mode: PanZoomMode): void;
    /**
       * Returns a bitmask indicating the currently-enabled modes.
       * @see {@link setModeEnabled}
       */
    getMode(): PanZoomMode;
}

/** A tool that allows users to enter and edit text. */
declare class TextTool extends BaseTool {
    private editor;
    private localizationTable;
    private textStyleValue;
    private textStyle;
    private anchorControl;
    private contentTransform;
    private textEditOverlay;
    private textInputElem;
    private textMeasuringCtx;
    private removeExistingCommand;
    constructor(editor: Editor, description: string, localizationTable: ToolLocalization);
    private initTextMeasuringCanvas;
    private getTextAscent;
    private flushInput;
    private updateTextInput;
    private startTextInput;
    setEnabled(enabled: boolean): void;
    onPointerDown({ current, allPointers }: PointerEvt): boolean;
    onGestureCancel(): void;
    setFontFamily(fontFamily: string): void;
    setColor(color: Color4): void;
    setFontSize(size: number): void;
    getTextStyle(): TextRenderingStyle;
    getStyleValue(): MutableReactiveValue<TextRenderingStyle>;
    private setTextStyle;
    onDestroy(): void;
}

/**
 * @internal
 * @packageDocumentation
 */

declare class Selection {
    private editor;
    private childwidgets;
    private originalRegion;
    private selectionTightBoundingBox;
    private transformers;
    private transform;
    private selectedElems;
    private outerContainer;
    private innerContainer;
    private backgroundElem;
    private hasParent;
    constructor(selectedElems: AbstractComponent[], editor: Editor, showContextMenu: (anchor: IVec2) => void);
    getBackgroundElem(): HTMLElement;
    getTransform(): Mat33;
    get preTransformRegion(): Rect2;
    get region(): Rect2;
    /**
       * Computes and returns the bounding box of the selection without
       * any additional padding. Computes directly from the elements that are selected.
       * @internal
       */
    computeTightBoundingBox(): Rect2;
    get regionRotation(): number;
    get preTransformedScreenRegion(): Rect2;
    get preTransformedScreenRegionRotation(): number;
    getScreenRegion(): Rect2;
    get screenRegionRotation(): number;
    setTransform(transform: Mat33, preview?: boolean): void;
    private getDeltaZIndexToMoveSelectionToTop;
    finalizeTransform(): void | Promise<void>;
    /** Sends all selected elements to the bottom of the visible image. */
    sendToBack(): SerializableCommand | null;
    private static ApplyTransformationCommand;
    private previewTransformCmds;
    recomputeRegion(): boolean;
    padRegion(): void;
    getMinCanvasSize(): number;
    getSelectedItemCount(): number;
    updateUI(): void;
    private removedFromImage;
    private addRemoveSelectionFromImage;
    private removeDeletedElemsFromSelection;
    private activeHandle;
    private backgroundDragging;
    onDragStart(pointer: Pointer): boolean;
    onDragUpdate(pointer: Pointer): void;
    onDragEnd(): void;
    onDragCancel(): void;
    scrollTo(): boolean;
    deleteSelectedObjects(): Command;
    private selectionDuplicatedAnimationTimeout;
    private runSelectionDuplicatedAnimation;
    duplicateSelectedObjects(): Promise<Command>;
    snapSelectedObjectsToGrid(): void;
    setHandlesVisible(showHandles: boolean): void;
    addTo(elem: HTMLElement): void;
    setToPoint(point: IVec2): void;
    cancelSelection(): void;
    getSelectedObjects(): AbstractComponent[];
}

declare class SelectionTool extends BaseTool {
    private editor;
    readonly modeValue: MutableReactiveValue<SelectionMode>;
    private selectionBuilder;
    private handleOverlay;
    private prevSelectionBox;
    private selectionBox;
    private removeSelectionScheduled;
    private startPoint;
    private expandingSelectionBox;
    private shiftKeyPressed;
    private snapToGrid;
    private lastPointer;
    private autoscroller;
    constructor(editor: Editor, description: string);
    private getSelectionColor;
    private makeSelectionBox;
    private showContextMenu;
    onContextMenu(event: ContextMenuEvt): boolean;
    private selectionBoxHandlingEvt;
    onPointerDown({ allPointers, current }: PointerEvt): boolean;
    onPointerMove(event: PointerEvt): void;
    private onMainPointerUpdated;
    onPointerUp(event: PointerEvt): void;
    onGestureCancel(): void;
    private lastSelectedObjects;
    private onSelectionUpdated;
    private zoomToSelection;
    private hasUnfinalizedTransformFromKeyPress;
    onKeyPress(event: KeyPressEvent): boolean;
    onKeyUp(evt: KeyUpEvent): boolean;
    onCopy(event: CopyEvent): boolean;
    setEnabled(enabled: boolean): void;
    getSelection(): Selection | null;
    /** @returns true if the selection is currently being created by the user. */
    isSelecting(): boolean;
    getSelectedObjects(): AbstractComponent[];
    setSelection(objects: AbstractComponent[]): void;
    private clearSelectionNoUpdateEvent;
    clearSelection(): void;
}

declare class SelectAllShortcutHandler extends BaseTool {
    private editor;
    constructor(editor: Editor);
    canReceiveInputInReadOnlyEditor(): boolean;
    onKeyPress(event: KeyPressEvent): boolean;
}

/**
 * A tool that handles paste events (e.g. as triggered by ctrl+V).
 *
 * @example
 * While `ToolController` has a `PasteHandler` in its default list of tools,
 * if a non-default set is being used, `PasteHandler` can be added as follows:
 * ```ts
 * const toolController = editor.toolController;
 * toolController.addTool(new PasteHandler(editor));
 * ```
 */
declare class PasteHandler extends BaseTool {
    private editor;
    constructor(editor: Editor);
    onPaste(event: PasteEvent, onComplete?: () => void): boolean;
    private addComponentsFromPaste;
    private doSVGPaste;
    private doTextPaste;
    private doImagePaste;
}

/**
 * This tool, when enabled, plays a sound representing the color of the portion of the display
 * currently under the cursor. This tool adds a button that can be navigated to with the tab key
 * that enables/disables the tool.
 *
 * This allows the user to explore the content of the display without a working screen.
 */
declare class SoundUITool extends BaseTool {
    private editor;
    private soundFeedback;
    private toggleButton;
    private toggleButtonContainer;
    constructor(editor: Editor, description: string);
    canReceiveInputInReadOnlyEditor(): boolean;
    private updateToggleButtonText;
    setEnabled(enabled: boolean): void;
    onKeyPress(event: KeyPressEvent): boolean;
    private lastPointerPos;
    onPointerDown({ current, allPointers }: PointerEvt): boolean;
    onPointerMove({ current }: PointerEvt): void;
    onPointerUp(_event: PointerEvt): void;
    onGestureCancel(): void;
}

type KeyPressListener = (event: KeyPressEvent) => boolean;
declare class ToolbarShortcutHandler extends BaseTool {
    private listeners;
    constructor(editor: Editor);
    registerListener(listener: KeyPressListener): void;
    removeListener(listener: KeyPressListener): void;
    onKeyPress(event: KeyPressEvent): boolean;
}

declare class ActionButtonWidget extends BaseWidget {
    #private;
    protected makeIcon: () => Element | null;
    protected title: string;
    protected clickAction: () => void;
    protected mustBeToplevel: boolean;
    constructor(editor: Editor, id: string, makeIcon: () => Element | null, title: string, clickAction: () => void, localizationTable?: ToolbarLocalization, mustBeToplevel?: boolean, autoDisableInReadOnlyEditors?: boolean);
    /**
       * Sets the text shown in a help overlay for this button.
       *
       * See {@link getHelpText}.
       */
    setHelpText(helpText: string): void;
    protected getHelpText(): string | undefined;
    protected shouldAutoDisableInReadOnlyEditor(): boolean;
    protected handleClick(): void;
    protected getTitle(): string;
    protected createIcon(): Element | null;
    protected fillDropdown(_dropdown: HTMLElement): boolean;
    mustBeInToplevelMenu(): boolean;
}

declare abstract class BaseToolWidget extends BaseWidget {
    protected targetTool: BaseTool;
    constructor(editor: Editor, targetTool: BaseTool, id: string, localizationTable?: ToolbarLocalization);
    protected shouldAutoDisableInReadOnlyEditor(): boolean;
    protected handleClick(): void;
    protected onKeyPress(event: KeyPressEvent): boolean;
    addTo(parent: HTMLElement): HTMLElement;
}

/** Represents a style that can be applied to a pen tool. */
interface PenTypeRecord {
    name: string;
    id: string;
    isShapeBuilder?: boolean;
    factory: ComponentBuilderFactory;
}
/**
 * This toolbar widget allows a user to control a single {@link Pen} tool.
 *
 * See also {@link AbstractToolbar.addDefaultToolWidgets}.
 */
declare class PenToolWidget extends BaseToolWidget {
    private tool;
    private updateInputs;
    protected penTypes: Readonly<PenTypeRecord>[];
    protected shapelikeIDs: string[];
    private static idCounter;
    constructor(editor: Editor, tool: Pen, localization?: ToolbarLocalization);
    protected getTitle(): string;
    private getCurrentPenTypeIdx;
    private getCurrentPenType;
    private createIconForRecord;
    protected createIcon(): Element;
    private createPenTypeSelector;
    protected createStrokeCorrectionOptions(helpOverlay?: HelpDisplay): {
        update: () => void;
        addTo: (parent: HTMLElement) => void;
    };
    protected getHelpText(): string;
    protected fillDropdown(dropdown: HTMLElement, helpDisplay?: HelpDisplay): boolean;
    protected onKeyPress(event: KeyPressEvent): boolean;
    serializeState(): SavedToolbuttonState;
    deserializeFrom(state: SavedToolbuttonState): void;
}

declare class TextToolWidget extends BaseToolWidget {
    private tool;
    private updateDropdownInputs;
    constructor(editor: Editor, tool: TextTool, localization?: ToolbarLocalization);
    protected getTitle(): string;
    protected createIcon(): Element;
    private static idCounter;
    protected fillDropdown(dropdown: HTMLElement): boolean;
    serializeState(): SavedToolbuttonState;
    deserializeFrom(state: SavedToolbuttonState): void;
}

/** This toolbar widget allows controlling the editor's {@link PanZoom} tool(s). */
declare class HandToolWidget extends BaseToolWidget {
    private allowTogglingBaseTool;
    protected overridePanZoomTool: PanZoom;
    constructor(editor: Editor, tool: PanZoom, localizationTable: ToolbarLocalization);
    private static getPrimaryHandTool;
    private static getOverrideHandTool;
    protected shouldAutoDisableInReadOnlyEditor(): boolean;
    protected getTitle(): string;
    protected createIcon(): Element;
    protected handleClick(): void;
    protected getHelpText(): string;
    protected fillDropdown(dropdown: HTMLElement, helpDisplay?: HelpDisplay): boolean;
    setSelected(selected: boolean): void;
    serializeState(): SavedToolbuttonState;
    deserializeFrom(state: SavedToolbuttonState): void;
}

declare class SelectionToolWidget extends BaseToolWidget {
    private tool;
    private updateFormatMenu;
    private hasSelectionValue;
    constructor(editor: Editor, tool: SelectionTool, localization?: ToolbarLocalization);
    private resizeImageToSelection;
    protected onKeyPress(event: KeyPressEvent): boolean;
    protected getTitle(): string;
    protected createIcon(): Element;
    protected getHelpText(): string;
    protected createSelectionActions(helpDisplay?: HelpDisplay): {
        container: HTMLDivElement;
    };
    protected fillDropdown(dropdown: HTMLElement, helpDisplay?: HelpDisplay): boolean;
    serializeState(): SavedToolbuttonState;
    deserializeFrom(state: SavedToolbuttonState): void;
}

declare class EraserToolWidget extends BaseToolWidget {
    private tool;
    private updateInputs;
    constructor(editor: Editor, tool: Eraser, localizationTable?: ToolbarLocalization);
    protected getHelpText(): string;
    protected getTitle(): string;
    private makeIconForType;
    protected createIcon(): Element;
    private static idCounter;
    private makeEraserTypeSelector;
    protected fillDropdown(dropdown: HTMLElement, helpDisplay?: HelpDisplay): boolean;
    serializeState(): SavedToolbuttonState;
    deserializeFrom(state: SavedToolbuttonState): void;
}

/**
 * Provides a widget that allows inserting or modifying raster images.
 *
 * It's possible to customize the file picker used by this widget through {@link EditorSettings.image}.
 *
 * @example
 * ```ts,runnable
 * import { Editor, makeEdgeToolbar, InsertImageWidget } from 'easydrawer';
 *
 * const editor = new Editor(document.body);
 * const toolbar = makeEdgeToolbar(editor);
 *
 * toolbar.addWidget(new InsertImageWidget(editor));
 * ```
 */
declare class InsertImageWidget extends BaseWidget {
    private images;
    private imagesPreview;
    private selectedFiles;
    private imageAltTextInput;
    private statusView;
    private submitButton;
    constructor(editor: Editor, localization?: ToolbarLocalization);
    protected getTitle(): string;
    protected createIcon(): Element | null;
    protected setDropdownVisible(visible: boolean): void;
    protected handleClick(): void;
    private static nextInputId;
    protected fillDropdown(dropdown: HTMLElement): boolean;
    private onImageDataUpdate;
    private hideDialog;
    private updateImageSizeDisplay;
    private updateInputs;
}

declare class DocumentPropertiesWidget extends BaseWidget {
    private updateDropdownContent;
    constructor(editor: Editor, localizationTable?: ToolbarLocalization);
    protected getTitle(): string;
    protected createIcon(): Element;
    protected handleClick(): void;
    private dropdownUpdateQueued;
    private queueDropdownUpdate;
    private updateDropdown;
    private setBackgroundColor;
    private getBackgroundColor;
    private removeBackgroundComponents;
    /** Replace existing background components with a background of the given type. */
    private setBackgroundType;
    /** Returns the type of the topmost background component */
    private getBackgroundType;
    private updateImportExportRectSize;
    protected getHelpText(): string;
    setBackgroundGrid(): void;
    setBackgroundDot(): void;
    updateBackgroundColor(color: Color4): void;
    setBackgroundSolid(): void;
    removeBackground(): void;
    private static idCounter;
    protected fillDropdown(dropdown: HTMLElement, helpDisplay?: HelpDisplay): boolean;
}

type OnColorChangeListener = (color: Color4) => void;
declare function makeColorInput(editor: Editor, onColorChange: OnColorChangeListener): {
    input: HTMLInputElement;
    container: HTMLSpanElement;
    setValue: (color: Color4 | string) => void;
    closePicker: () => void;
    registerWithHelpTextDisplay: (helpDisplay: HelpDisplay) => void;
};

/**
 * @example
 *
 * ```ts,runnable
 * import { makeDropdownToolbar, Editor } from 'easydrawer';
 *
 * const editor = new Editor(document.body);
 * const toolbar = makeDropdownToolbar(editor);
 * toolbar.addDefaults();
 *
 * toolbar.addExitButton(editor => {
 *   // TODO
 * });
 *
 * toolbar.addSaveButton(editor => {
 *   // TODO
 * });
 * ```
 *
 * Returns a subclass of {@link AbstractToolbar}.
 *
 * @see
 * - {@link makeEdgeToolbar}
 * - {@link AbstractToolbar.addSaveButton}
 * - {@link AbstractToolbar.addExitButton}
 */
declare function makeDropdownToolbar(editor: Editor): DropdownToolbar;
declare class DropdownToolbar extends AbstractToolbar {
    protected container: HTMLElement;
    private resizeObserver;
    private widgetOrderCounter;
    private overflowWidget;
    /** @internal */
    constructor(editor: Editor, parent: HTMLElement, localizationTable: ToolbarLocalization);
    private reLayoutQueued;
    private queueReLayout;
    private reLayout;
    protected addWidgetInternal(widget: BaseWidget): void;
    protected removeWidgetInternal(widget: BaseWidget): void;
    addSpacer(options?: Partial<SpacerOptions>): void;
    /**
       * Adds a widget that toggles the overflow menu. Call `addOverflowWidget` to ensure
       * that this widget is in the correct space (if shown).
       *
       * @example
       * ```ts
       * toolbar.addDefaultToolWidgets();
       * toolbar.addOverflowWidget();
       * toolbar.addDefaultActionButtons();
       * ```
       * shows the overflow widget between the default tool widgets and the default action buttons,
       * if shown.
       */
    addOverflowWidget(): void;
    /**
       * Adds both the default tool widgets and action buttons. Equivalent to
       * ```ts
       * toolbar.addDefaultToolWidgets();
       * toolbar.addOverflowWidget();
       * toolbar.addDefaultActionButtons();
       * ```
       */
    addDefaults(): void;
    protected onRemove(): void;
    getWidgetById(id: string): BaseWidget | null;
}

/**
 * Creates an `EdgeToolbar`.
 *
 * [Credit for the original design of this UI](https://www.figma.com/file/NA5F2AMWO3wUuaoDfUaAb8/Material-3-wireframes?type=design&node-id=54490%3A1103&mode=design&t=Ee0UwnPnQ2bNC2uM-1).
 *
 * @example
 *
 * ```ts,runnable
 * import { makeEdgeToolbar, Editor } from 'easydrawer';
 *
 * const editor = new Editor(document.body);
 * const toolbar = makeEdgeToolbar(editor);
 * toolbar.addDefaults();
 *
 * toolbar.addSaveButton(editor => {
 *   // TODO
 * });
 *
 * toolbar.addExitButton(editor => {
 *   // TODO
 * });
 * ```
 *
 * @see
 * - {@link makeDropdownToolbar}
 * - {@link AbstractToolbar.addSaveButton}
 * - {@link AbstractToolbar.addExitButton}
 */
declare function makeEdgeToolbar(editor: Editor): AbstractToolbar;

declare class DummyRenderer extends AbstractRenderer {
    clearedCount: number;
    renderedPathCount: number;
    lastFillStyle: RenderingStyle | null;
    lastPoint: IVec2 | null;
    objectNestingLevel: number;
    lastText: string | null;
    lastImage: RenderableImage | null;
    pointBuffer: IVec2[];
    constructor(viewport: Viewport);
    displaySize(): IVec2;
    clear(): void;
    protected beginPath(startPoint: IVec2): void;
    protected endPath(style: RenderingStyle): void;
    protected lineTo(point: IVec2): void;
    protected moveTo(point: IVec2): void;
    protected traceCubicBezierCurve(p1: IVec2, p2: IVec2, p3: IVec2): void;
    protected traceQuadraticBezierCurve(controlPoint: IVec2, endPoint: IVec2): void;
    drawPoints(..._points: IVec2[]): void;
    drawText(text: string, _transform: Mat33, _style: TextRenderingStyle): void;
    drawImage(image: RenderableImage): void;
    startObject(boundingBox: Rect2, _clip: boolean): void;
    endObject(): void;
    isTooSmallToRender(_rect: Rect2): boolean;
    canRenderFromWithoutDataLoss(other: AbstractRenderer): other is DummyRenderer;
    renderFromOtherOfSameType(transform: Mat33, other: AbstractRenderer): void;
    toString(): string;
}

type FromViewportOptions = {
    sanitize?: boolean;
    /**
       * Rather than having the top left of the `viewBox` set to (0, 0),
       * if `useViewBoxForPositioning` is `true`, the `viewBox`'s top left
       * is based on the top left of the rendering viewport's `visibleRect`.
       */
    useViewBoxForPositioning?: boolean;
};
type DrawWithSVGParentContext = {
    sanitize: boolean;
};
/**
 * Renders onto an `SVGElement`.
 *
 * @see {@link Editor.toSVG}
 */
declare class SVGRenderer extends AbstractRenderer {
    private elem;
    private sanitize;
    private lastPathStyle;
    private lastPathString;
    private lastContainerIDList;
    private objectElems;
    private overwrittenAttrs;
    /**
       * Creates a renderer that renders onto `elem`. If `sanitize`, don't render potentially untrusted data.
       *
       * `viewport` is used to determine the translation/rotation/scaling/output size of the rendered
       * data.
       */
    constructor(elem: SVGSVGElement, viewport: Viewport, sanitize?: boolean);
    private addStyleSheet;
    setRootSVGAttribute(name: string, value: string | null): void;
    displaySize(): IVec2;
    clear(): void;
    protected addPathToSVG(): SVGPathElement | null;
    drawPath(pathSpec: RenderablePathSpec): void;
    private transformFrom;
    private textContainer;
    private textContainerTransform;
    private textParentStyle;
    drawText(text: string, transform: Mat33, style: TextRenderingStyle): void;
    drawImage(image: RenderableImage): void;
    startObject(boundingBox: Rect2): void;
    endObject(loaderData?: LoadSaveDataTable, elemClassNames?: string[]): void;
    private unimplementedMessage;
    protected beginPath(_startPoint: IVec2): void;
    protected endPath(_style: RenderingStyle): void;
    protected lineTo(_point: IVec2): void;
    protected moveTo(_point: IVec2): void;
    protected traceCubicBezierCurve(_controlPoint1: IVec2, _controlPoint2: IVec2, _endPoint: IVec2): void;
    protected traceQuadraticBezierCurve(_controlPoint: IVec2, _endPoint: IVec2): void;
    drawPoints(...points: IVec2[]): void;
    /**
       * Adds a **copy** of the given element directly to the container
       * SVG element, **without applying transforms**.
       *
       * If `sanitize` is enabled, this does nothing.
       */
    drawSVGElem(elem: SVGElement): void;
    /**
       * Allows rendering directly to the underlying SVG element. Rendered
       * content is added to a `<g>` element that's passed as `parent` to `callback`.
       *
       * **Note**: Unlike {@link drawSVGElem}, this method can be used even if `sanitize` is `true`.
       * In this case, it's the responsibility of `callback` to ensure that everything added
       * to `parent` is safe to render.
       */
    drawWithSVGParent(callback: (parent: SVGGElement, context: DrawWithSVGParentContext) => void): void;
    isTooSmallToRender(_rect: Rect2): boolean;
    /**
       * Creates a new SVG element and `SVGRenerer` with `width`, `height`, `viewBox`,
       * and other metadata attributes set for the given `Viewport`.
       *
       * If `options` is a `boolean`, it is interpreted as whether to sanitize (not add unknown
       * SVG entities to) the output.
       */
    static fromViewport(viewport: Viewport, options?: FromViewportOptions | boolean): {
        element: SVGSVGElement;
        renderer: SVGRenderer;
    };
}

/**
 * Renders onto a `CanvasRenderingContext2D`.
 *
 * **Example**:
 * [[include:doc-pages/inline-examples/canvas-renderer.md]]
 */
declare class CanvasRenderer extends AbstractRenderer {
    private ctx;
    private ignoreObjectsAboveLevel;
    private ignoringObject;
    private currentObjectBBox;
    private minSquareCurveApproxDist;
    private minRenderSizeAnyDimen;
    private minRenderSizeBothDimens;
    /**
       * Creates a new `CanvasRenderer` that renders to the given rendering context.
       * The `viewport` is used to determine the translation/rotation/scaling of the content
       * to draw.
       */
    constructor(ctx: CanvasRenderingContext2D, viewport: Viewport);
    private transformBy;
    canRenderFromWithoutDataLoss(other: AbstractRenderer): other is CanvasRenderer;
    renderFromOtherOfSameType(transformBy: Mat33, other: AbstractRenderer): void;
    setDraftMode(draftMode: boolean): void;
    displaySize(): IVec2;
    clear(): void;
    protected beginPath(startPoint: IVec2): void;
    protected endPath(style: RenderingStyle): void;
    protected lineTo(point: IVec2): void;
    protected moveTo(point: IVec2): void;
    protected traceCubicBezierCurve(p1: IVec2, p2: IVec2, p3: IVec2): void;
    protected traceQuadraticBezierCurve(controlPoint: IVec3, endPoint: IVec3): void;
    drawPath(path: RenderablePathSpec): void;
    drawText(text: string, transform: Mat33, style: TextRenderingStyle): void;
    drawImage(image: RenderableImage): void;
    private clipLevels;
    startObject(boundingBox: Rect2, clip?: boolean): void;
    endObject(): void;
    /**
       * Returns a reference to the underlying `CanvasRenderingContext2D`.
       * This can be used to render custom content not supported by {@link AbstractRenderer}.
       * However, such content won't support {@link SVGRenderer} or {@link TextOnlyRenderer}
       * by default.
       *
       * Use with caution.
       */
    drawWithRawRenderingContext(callback: (ctx: CanvasRenderingContext2D) => void): void;
    drawPoints(...points: IVec2[]): void;
    isTooSmallToRender(rect: Rect2): boolean;
    static fromViewport(exportViewport: Viewport, options?: {
        canvasSize?: IVec2;
        maxCanvasDimen?: number;
    }): {
        renderer: CanvasRenderer;
        element: HTMLCanvasElement;
    };
}

declare enum RenderingMode {
    DummyRenderer = 0,
    CanvasRenderer = 1
}
/**
 * Handles `HTMLCanvasElement`s (or other drawing surfaces if being used) used to display the editor's contents.
 *
 * @example
 * ```
 * const editor = new Editor(document.body);
 * const w = editor.display.width;
 * const h = editor.display.height;
 * const center = Vec2.of(w / 2, h / 2);
 * const colorAtCenter = editor.display.getColorAt(center);
 * ```
 */
declare class Display {
    private editor;
    private parent;
    private dryInkRenderer;
    private wetInkRenderer;
    private textRenderer;
    private textRerenderOutput;
    private cache;
    private devicePixelRatio;
    private resizeSurfacesCallback?;
    private flattenCallback?;
    /** @internal */
    constructor(editor: Editor, mode: RenderingMode, parent: HTMLElement | null);
    /**
       * @returns the visible width of the display (e.g. how much
       * space the display's element takes up in the x direction
       * in the DOM).
       */
    get width(): number;
    /** @returns the visible height of the display. See {@link width}. */
    get height(): number;
    /** @internal */
    getCache(): RenderingCache;
    /**
       * @returns the color at the given point on the dry ink renderer, or `null` if `screenPos`
       * 	is not on the display.
       */
    getColorAt: (_screenPos: IVec2) => Color4 | null;
    private initializeCanvasRendering;
    private initializeTextRendering;
    /**
       * Sets the device-pixel-ratio.
       *
       * Intended for debugging. Users do not need to call this manually.
       *
       * @internal
       */
    setDevicePixelRatio(dpr: number): Promise<void> | undefined;
    /** @internal */
    getDevicePixelRatio(): number;
    /**
       * Rerenders the text-based display.
       * The text-based display is intended for screen readers and can be navigated to by pressing `tab`.
       */
    rerenderAsText(): void;
    /**
       * Clears the main drawing surface and otherwise prepares for a rerender.
       *
       * @returns the dry ink renderer.
       */
    startRerender(): AbstractRenderer;
    /**
       * If `draftMode`, the dry ink renderer is configured to render
       * low-quality output.
       */
    setDraftMode(draftMode: boolean): void;
    /** @internal */
    getDryInkRenderer(): AbstractRenderer;
    /**
       * @returns The renderer used for showing action previews (e.g. an unfinished stroke).
       * The `wetInkRenderer`'s surface is stacked above the `dryInkRenderer`'s.
       */
    getWetInkRenderer(): AbstractRenderer;
    /** Re-renders the contents of the wetInkRenderer onto the dryInkRenderer. */
    flatten(): void;
}

/**
 * Dispatch a pen event to the currently selected tool.
 * Intended for unit tests.
 *
 * @see {@link sendTouchEvent}
 */
declare function sendPenEvent(editor: Editor, eventType: PointerEvtType, point: IVec2, allPointers?: Pointer[], deviceType?: PointerDevice): Pointer;

/**
 * Dispatch a touch event to the currently selected tool. Intended for unit tests.
 *
 * @see {@link sendPenEvent}
 *
 * @example
 * **Simulating a horizontal swipe gesture:**
 * ```ts
 * sendTouchEvent(editor, InputEvtType.PointerDownEvt, Vec2.of(0, 0));
 * for (let i = 1; i <= 10; i++) {
 *   jest.advanceTimersByTime(10);
 *   sendTouchEvent(editor, InputEvtType.PointerMoveEvt, Vec2.of(i * 10, 0));
 * }
 * ```
 *
 * @example
 * **Simulating a pinch gesture.** This example assumes that you're using [Jest with timer mocks enabled](https://jestjs.io/docs/timer-mocks).
 * ```ts
 * let firstPointer = sendTouchEvent(editor, InputEvtType.PointerDownEvt, Vec2.of(0, 0));
 * let secondPointer = sendTouchEvent(editor, InputEvtType.PointerDownEvt, Vec2.of(100, 0), [ firstPointer ]);
 *
 * // Simulate a pinch
 * const maxIterations = 10;
 * for (let i = 0; i < maxIterations; i++) {
 *   // Use the unit testing framework's tool for increasing the current time
 *   // returned by (new Date()).getTime(), etc.
 *   jest.advanceTimersByTime(100);
 *
 *   const point1 = Vec2.of(-i * 5, 0);
 *   const point2 = Vec2.of(i * 5 + 100, 0);
 *
 *   firstPointer = sendTouchEvent(editor, InputEvtType.PointerMoveEvt, point1, [ secondPointer ]);
 *   secondPointer = sendTouchEvent(editor, InputEvtType.PointerMoveEvt, point2, [ firstPointer ]);
 * }
 * ```
 */
declare function sendTouchEvent(editor: Editor, eventType: PointerEvtType, screenPos: IVec2, allOtherPointers?: Pointer[]): Pointer;

interface KeyCombination {
    /** A key (e.g. `a`, `b`, `control`). */
    readonly key: string;
    /**
       * The layout-independent name of the key being pressed. For example,
       * KeyA for the `a` key.
       */
    readonly code?: string;
    /**
       * Whether the shift key must be pressed to trigger the shortcut.
       */
    readonly shiftKey: boolean | undefined;
    /** Whether the control key must be pressed to trigger the shortcut */
    readonly ctrlKey: boolean;
    /** Whether the alt key must be pressed to trigger the shortcut */
    readonly altKey: boolean;
    /** Whether the meta key must be pressed to trigger the shortcut */
    readonly metaKey: boolean;
    /** True if this shortcut/key combination applies for either control or meta. */
    readonly controlOrMeta: boolean;
}
/** Represents a key combination that can trigger a keyboard shortcut. */
declare class KeyBinding implements KeyCombination {
    /** @inheritdoc */
    readonly key: string;
    /**
       * If undefined, the state of the shift key is ignored.
       */
    readonly shiftKey: boolean | undefined;
    /** @inheritdoc */
    readonly ctrlKey: boolean;
    /** @inheritdoc */
    readonly altKey: boolean;
    /** @inheritdoc */
    readonly metaKey: boolean;
    /** @inheritdoc */
    readonly controlOrMeta: boolean;
    constructor(trigger: KeyCombination);
    /** Returns true if and only if `keyEvent` should trigger this shortcut. */
    matchesEvent(keyEvent: Partial<KeyCombination>): boolean;
    /**
       * Returns a string representation of this shortcut in the same format accepted by
       * {@link fromString}.
       */
    toString(): string;
    /**
       * Accepts a string in the form `modifier1+modifier2+...+key` (e.g. `Ctrl+Shift+a`)
       * and returns the corresponding `KeyboardShortcut`.
       */
    static fromString(shortcutStr: string): KeyBinding;
}

type ShortcutDictionary = Record<string, KeyBinding[]>;
/**
 * Allows adding/changing keyboard shortcuts. This class provides static methods for registering
 * default shortcuts. An instance of this class must be used to access or change keyboard shortcuts.
 */
declare class KeyboardShortcutManager {
    private static shortcuts;
    private static shortcutDefaultDescriptions;
    private static shortcutLocalizedDescriptions;
    private shortcutOverrides;
    /**
       * Creates a new `ShortcutManager` with an initial set of shortcut overrides.
       *
       * @internal
       */
    constructor(initialOverrides: ShortcutDictionary);
    /**
       * Override an existing shortcut with a custom set of triggers.
       * @internal
       */
    overrideShortcut(shortcutId: string, overrideWith: KeyBinding[]): void;
    /** Returns true if `keyEvent` matches the shortcut with `shortcutId`. @internal */
    matchesShortcut(shortcutId: string, keyEvent: Partial<KeyCombination>): boolean;
    /**
       * Registers a default keyboard shortcut that can be overridden by individual instances
       * of `ShortcutManager`. Note that `id` should be a globally unique identifier.
       *
       * Only the first call to this method for a given `id` has an effect.
       *
       * @example
       * ```ts
       * const shortcutId = 'io.github.personalizedrefrigerator.easydraw.select-all';
       *
       * // Associate two shortcuts with the same ID
       * const shortcut1 = KeyBinding.fromString('ctrlOrMeta+a');
       * const shortcut2 = KeyBinding.fromString('ctrlOrMeta+shift+a');
       * KeyboardShortcutManager.registerDefaultKeyboardShortcut(
       * 	shortcutId,
       * 	[ shortcut1, shortcut2 ],
       * 	"Select All",
       * );
       *
       * // Provide a localized description
       * KeyboardShortcutManager.provideShortcutDescription(
       * 	shotcutId,
       * 	'es',
       * 	'Seleccionar todo',
       * );
       * ```
       *
       * @internal
       */
    static registerDefaultKeyboardShortcut(id: string, shortcuts: (KeyBinding | string)[], defaultDescription: string): boolean;
    /** Provides a localized description of a keyboard shortcut. @internal */
    static provideShortcutDescription(id: string, locale: string, description: string): void;
    /**
       * Gets all registered keyboard shortcut IDs.
       *
       * @see {@link getShortcutDescription}
       */
    static getAllShortcutIds(): string[];
    /**
       * Get the default keybindings associated with a keyboard shortcut.
       *
       * Any keybinding in the resultant list, by default, can trigger the function associated
       * with the shortcut.
       */
    static getShortcutDefaultKeybindings(shortcutId: string): KeyBinding[];
    /**
       * Get a description of a keyboard shortcut.
       *
       * `localeList`, if given, attempts to
       */
    static getShortcutDescription(id: string, localeList?: readonly string[]): string | null;
}

type AnnounceRedoCallback = (command: Command) => void;
type AnnounceUndoCallback = (command: Command) => void;
declare class UndoRedoHistory {
    #private;
    private readonly editor;
    private announceRedoCallback;
    private announceUndoCallback;
    private readonly maxUndoRedoStackSize;
    constructor(editor: Editor, announceRedoCallback: AnnounceRedoCallback, announceUndoCallback: AnnounceUndoCallback);
    private fireUpdateEvent;
    push(command: Command, apply?: boolean): void;
    undo(): void | Promise<void>;
    redo(): void | Promise<void>;
    get undoStackSize(): number;
    get redoStackSize(): number;
    clearAll(): void;
}

/**
 * Adjusts the current editor theme such that colors have appropriate contrast.
 *
 * As this method overrides CSS variables using the `.style` property,
 * **assumes** all original theme variables are set using CSS and not the `.style` property.
 *
 * If the editor changes theme in response to the system theme, this method should be
 * called whenever the system theme changes (e.g. by using [the `matchMedia`](https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia)
 * method).
 *
 * @example
 * ```ts,runnable
 * import { Editor, adjustEditorThemeForContrast } from 'easydrawer';
 *
 * const editor = new Editor(document.body);
 * editor.addToolbar();
 *
 * const css = `
 *   :root .imageEditorContainer {
 *     --background-color-1: #ffff77;
 *     --foreground-color-1: #fff;
 *     --background-color-2: #ffff99;
 *     --foreground-color-2: #ffff88;
 *     --background-color-3: #ddffff;
 *     --foreground-color-3: #eeffff;
 *     --selection-background-color: #9f7;
 *     --selection-foreground-color: #98f;
 *   }
 *
 *   @media screen and (prefers-color-scheme: dark) {
 *     :root .imageEditorContainer {
 *       --background-color-1: black;
 *     }
 *   }
 * `;
 * editor.addStyleSheet(css);
 *
 * adjustEditorThemeForContrast(editor);
 *
 * // Because adjustEditorThemeForContrast overrides the current theme, it should be called again
 * // to allow the editor to switch between light/dark themes.
 * window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
 *   adjustEditorThemeForContrast(editor);
 * });
 *
 * window.matchMedia('print').addEventListener('change', () => {
 *   adjustEditorThemeForContrast(editor);
 * });
 * ```
 */
declare function adjustEditorThemeForContrast(editor: Editor, options?: {
    dontClearOverrides: boolean;
}): void;

/**
 * Contains the current version of the library -- used
 * internaly (e.g. for documentation).
 * @internal
 */
declare const _default: {
    number: string;
};

interface TextRenderingStyle {
    readonly size: number;
    /** Name of the font. */
    readonly fontFamily: string;
    /** For example, `bold`. Like CSS `font-weight`. */
    readonly fontWeight?: string;
    /** For example, `italic`. Like CSS `font-style`. */
    readonly fontStyle?: string;
    readonly fontVariant?: string;
    /** Fill and stroke of the text. */
    readonly renderingStyle: RenderingStyle;
}

interface RenderableImage {
    transform: Mat33;
    image: HTMLImageElement | HTMLCanvasElement;
    base64Url: string;
    label?: string;
}
/**
 * Abstract base class for renderers.
 *
 * @see {@link EditorImage.render}
 */
declare abstract class AbstractRenderer {
    private viewport;
    private selfTransform;
    private transformStack;
    protected constructor(viewport: Viewport);
    /**
       * this.canvasToScreen, etc. should be used instead of the corresponding
       * methods on `Viewport`, because the viewport may not accurately reflect
       * what is rendered.
       */
    protected getViewport(): Viewport;
    abstract displaySize(): IVec2;
    abstract clear(): void;
    protected abstract beginPath(startPoint: IVec2): void;
    protected abstract endPath(style: RenderingStyle): void;
    protected abstract lineTo(point: IVec2): void;
    protected abstract moveTo(point: IVec2): void;
    protected abstract traceCubicBezierCurve(p1: IVec2, p2: IVec2, p3: IVec2): void;
    protected abstract traceQuadraticBezierCurve(controlPoint: IVec2, endPoint: IVec2): void;
    abstract drawText(text: string, transform: Mat33, style: TextRenderingStyle): void;
    abstract drawImage(image: RenderableImage): void;
    abstract isTooSmallToRender(rect: Rect2): boolean;
    setDraftMode(_draftMode: boolean): void;
    protected objectLevel: number;
    private currentPaths;
    private flushPath;
    /**
       * Draws a styled path. If within an object started by {@link startObject},
       * the resultant path may not be visible until {@link endObject} is called.
       */
    drawPath(path: RenderablePathSpec): void;
    drawRect(rect: Rect2, lineWidth: number, lineFill: RenderingStyle): void;
    /** Draws a filled rectangle. */
    fillRect(rect: Rect2, fill: Color4): void;
    /**
       * This should be called whenever a new object is being drawn.
       *
       * @param _boundingBox The bounding box of the object to be drawn.
       * @param _clip Whether content outside `_boundingBox` should be drawn. Renderers
       *              that override this method are not required to support `_clip`.
       */
    startObject(_boundingBox: Rect2, _clip?: boolean): void;
    /**
       * Notes the end of an object.
       * @param _loaderData - a map from strings to JSON-ifyable objects
       * and contains properties attached to the object by whatever loader loaded the image. This
       * is used to preserve attributes not supported by easydrawer when loading/saving an image.
       * Renderers may ignore this.
       *
       * @param _objectTags - a list of labels (e.g. `className`s) to be attached to the object.
       * Renderers may ignore this.
       */
    endObject(_loaderData?: LoadSaveDataTable, _objectTags?: string[]): void;
    protected getNestingLevel(): number;
    abstract drawPoints(...points: IVec2[]): void;
    canRenderFromWithoutDataLoss(_other: AbstractRenderer): boolean;
    renderFromOtherOfSameType(_renderTo: Mat33, other: AbstractRenderer): void;
    setTransform(transform: Mat33 | null): void;
    pushTransform(transform: Mat33): void;
    popTransform(): void;
    getCanvasToScreenTransform(): Mat33;
    canvasToScreen(vec: IVec2): IVec2;
    getSizeOfCanvasPixelOnScreen(): number;
    private visibleRectOverride;
    /**
       * @internal
       */
    overrideVisibleRect(rect: Rect2 | null): void;
    getVisibleRect(): Rect2;
}

interface CacheProps {
    createRenderer(): AbstractRenderer;
    isOfCorrectType(renderer: AbstractRenderer): boolean;
    blockResolution: IVec2;
    cacheSize: number;
    maxScale: number;
    minProportionalRenderTimePerCache: number;
    minProportionalRenderTimeToUseCache: number;
}

declare class RenderingCache {
    private sharedState;
    private recordManager;
    private rootNode;
    constructor(cacheProps: CacheProps);
    render(screenRenderer: AbstractRenderer, image: ImageNode, viewport: Viewport): void;
    getDebugInfo(): string;
    setIsDebugMode(debugMode: boolean): void;
}

declare enum EditorImageEventType {
    ExportViewportChanged = 0,
    AutoresizeModeChanged = 1,
    ComponentAdded = 2,
    ComponentRemoved = 3
}
interface StateChangeEvent {
    kind: EditorImageEventType.ExportViewportChanged | EditorImageEventType.AutoresizeModeChanged;
    image: EditorImage;
}
interface ComponentAddRemoveEvent {
    kind: EditorImageEventType.ComponentAdded | EditorImageEventType.ComponentRemoved;
    image: EditorImage;
    componentId: string;
}
type EditorImageEvent = StateChangeEvent | ComponentAddRemoveEvent;
type EditorImageNotifier = EventDispatcher<EditorImageEventType, EditorImageEvent>;
/**
 * A callback used to
 * 1. pause the render process
 * 2. observe progress through `componentsProcessed` and `totalComponents`
 * 3. stop the render process early by returning `false`.
 */
type PreRenderComponentCallback = (component: AbstractComponent, componentsProcessed: number, totalComponents: number) => Promise<boolean>;
/**
 * Handles lookup/storage of elements in the image.
 *
 * `easydrawer` images are made up of a collection of {@link AbstractComponent}s (which
 * includes {@link Stroke}s, {@link TextComponent}s, etc.). An `EditorImage`
 * is the data structure that stores these components.
 *
 * Here's how to do a few common operations:
 * - **Get all components in a {@link ~/math!Rect2 | Rect2}**:
 *    {@link EditorImage.getComponentsIntersecting}.
 * - **Draw an `EditorImage` onto a canvas/SVG**: {@link EditorImage.render}.
 * - **Adding a new component**: {@link EditorImage.addComponent}.
 *
 * **Example**:
 * [[include:doc-pages/inline-examples/image-add-and-lookup.md]]
 */
declare class EditorImage {
    private root;
    private background;
    private componentsById;
    private componentCount;
    /** Viewport for the exported/imported image. */
    private importExportViewport;
    private shouldAutoresizeExportViewport;
    readonly notifier: EditorImageNotifier;
    constructor(width?: number, height?: number);
    updateScreenSizeImage(width: number, height: number): void;
    getBackgroundComponents(): AbstractComponent[];
    findParent(elem: AbstractComponent): ImageNode | null;
    queueRerenderOf(elem: AbstractComponent): void;
    /** @internal */
    renderWithCache(screenRenderer: AbstractRenderer, cache: RenderingCache, viewport: Viewport): void;
    /**
       * Renders this image to the given `renderer`.
       *
       * If `viewport` is non-null, only components that can be seen from that viewport
       * will be rendered. If `viewport` is `null`, **all** components are rendered.
       *
       * **Example**:
       * [[include:doc-pages/inline-examples/canvas-renderer.md]]
       */
    render(renderer: AbstractRenderer, viewport: Viewport | null): void;
    /**
       * Like {@link renderAll}, but can be stopped early and paused.
       *
       * **Note**: If the image is being edited during an async rendering, there is no
       * guarantee that all nodes will be rendered correctly (some may be missing).
       *
       * @internal
       */
    renderAllAsync(renderer: AbstractRenderer, preRenderComponent: PreRenderComponentCallback): Promise<boolean>;
    /**
       * Renders all nodes, even ones not within the viewport.
       *
       * This can be slow for large images
       * @internal
       */
    renderAll(renderer: AbstractRenderer): void;
    /**
       * @returns all elements in the image, sorted by z-index (low to high).
       *
       * This can be slow for large images. If you only need all elemenst in part of the image,
       * consider using {@link getComponentsIntersecting} instead.
       *
       * **Note**: The result does not include background elements. See {@link getBackgroundComponents}.
       */
    getAllComponents(): AbstractComponent[];
    /** @deprecated in favor of {@link getAllComponents} */
    getAllElements(): AbstractComponent[];
    /** Returns the number of elements added to this image. @internal */
    estimateNumElements(): number;
    /** @deprecated @see getComponentsIntersecting */
    getElementsIntersectingRegion(region: Rect2, includeBackground?: boolean): AbstractComponent[];
    /**
       * @returns a list of `AbstractComponent`s intersecting `region`, sorted by increasing z-index.
       *
       * Components in the background layer are only included if `includeBackground` is `true`.
       */
    getComponentsIntersecting(region: Rect2, includeBackground?: boolean): AbstractComponent[];
    /** Called whenever (just after) an element is completely removed. @internal */
    onDestroyElement(elem: AbstractComponent): void;
    /** Called just after an element is added. @internal */
    private onElementAdded;
    /**
       * @returns the AbstractComponent with `id`, if it exists.
       *
       * @see {@link AbstractComponent.getId}
       */
    lookupElement(id: string): AbstractComponent | null;
    private addComponentDirectly;
    private removeElementDirectly;
    /**
       * Returns a command that adds the given element to the `EditorImage`.
       * If `applyByFlattening` is true, the content of the wet ink renderer is
       * rendered onto the main rendering canvas instead of doing a full re-render.
       *
       * @see {@link Display.flatten}
       *
       * **Example**:
       *
       * [[include:doc-pages/inline-examples/adding-a-stroke.md]]
       */
    static addComponent(elem: AbstractComponent, applyByFlattening?: boolean): SerializableCommand;
    /** @see EditorImage.addComponent */
    addComponent(component: AbstractComponent, applyByFlattening?: boolean): SerializableCommand;
    /** Alias for {@link addComponent}. @deprecated Prefer `.addComponent` */
    addElement(elem: AbstractComponent, applyByFlattening?: boolean): SerializableCommand;
    /** Alias for {@link addComponent}. @deprecated Prefer `.addComponent`. */
    static addElement(elem: AbstractComponent, applyByFlattening?: boolean): SerializableCommand;
    private static AddComponentCommand;
    /**
       * @returns a `Viewport` for rendering the image when importing/exporting.
       */
    getImportExportViewport(): Viewport;
    /**
       * @see {@link setImportExportRect}
       */
    getImportExportRect(): Rect2;
    /**
       * Sets the import/export rectangle to the given `imageRect`. Disables
       * autoresize if it was previously enabled.
       *
       * **Note**: The import/export rectangle is the same as the size of any
       * {@link BackgroundComponent}s (and other components that auto-resize).
       */
    setImportExportRect(imageRect: Rect2): SerializableCommand;
    /** @see {@link setAutoresizeEnabled} */
    getAutoresizeEnabled(): boolean;
    /**
       * Returns a `Command` that sets whether the image should autoresize when
       * {@link AbstractComponent}s are added/removed.
       *
       * @example
       *
       * ```ts,runnable
       * import { Editor } from 'easydrawer';
       *
       * const editor = new Editor(document.body);
       * const toolbar = editor.addToolbar();
       *
       * // Add a save button to demonstrate what the output looks like
       * // (it should change size to fit whatever was drawn)
       * toolbar.addSaveButton(() => {
       *   document.body.replaceChildren(editor.toSVG({ sanitize: true }));
       * });
       *
       * // Actually using setAutoresizeEnabled:
       * //
       * // To set autoresize without announcing for accessibility/making undoable
       * const addToHistory = false;
       * editor.dispatchNoAnnounce(editor.image.setAutoresizeEnabled(true), addToHistory);
       *
       * // Add to undo history **and** announce for accessibility
       * //editor.dispatch(editor.image.setAutoresizeEnabled(true), true);
       * ```
       */
    setAutoresizeEnabled(autoresize: boolean): Command;
    private setAutoresizeEnabledDirectly;
    /** Updates the size/position of the viewport */
    private autoresizeExportViewport;
    private settingExportRect;
    /**
       * Sets the import/export viewport directly, without returning a `Command`.
       * As such, this is not undoable.
       *
       * See setImportExportRect
       *
       * Returns true if changes to the viewport were made (and thus
       * ExportViewportChanged was fired.)
       */
    private setExportRectDirectly;
    private onExportViewportChanged;
    /**
       * @internal
       *
       * Enables debug mode for **all** `EditorImage`s.
       *
       * **Only use for debugging**.
       *
       * @internal
       */
    static setDebugMode(newDebugMode: boolean): void;
    private static SetImportExportRectCommand;
}
type TooSmallToRenderCheck = (rect: Rect2) => boolean;
/**
 * Part of the Editor's image. Does not handle fullscreen/invisible components.
 * @internal
 */
declare class ImageNode {
    private parent;
    private content;
    private bbox;
    private children;
    private targetChildCount;
    private id;
    private static idCounter;
    constructor(parent?: ImageNode | null);
    getId(): number;
    onContentChange(): void;
    getContent(): AbstractComponent | null;
    getParent(): ImageNode | null;
    protected getChildrenIntersectingRegion(region: Rect2, isTooSmallFilter?: TooSmallToRenderCheck): ImageNode[];
    getChildrenOrSelfIntersectingRegion(region: Rect2, isTooSmall?: TooSmallToRenderCheck): ImageNode[];
    /**
       * Returns a list of `ImageNode`s with content (and thus no children).
       * Override getChildrenIntersectingRegion to customize how this method
       * determines whether/which children are in `region`.
       *
       * @paran region - All resultant `ImageNode`s must intersect `region`.
       * @param isTooSmall - If `isTooSmall` returns true for an image node, that node
       *                     is excluded from the output.
       *
       */
    getLeavesIntersectingRegion(region: Rect2, isTooSmall?: TooSmallToRenderCheck): ImageNode[];
    getChildWithContent(target: AbstractComponent): ImageNode | null;
    getLeaves(): ImageNode[];
    addLeaf(leaf: AbstractComponent): ImageNode;
    protected static createLeafNode(parent: ImageNode, content: AbstractComponent): ImageNode;
    getBBox(): Rect2;
    recomputeBBox(bubbleUp: boolean): void;
    private unionBBoxWith;
    private updateParents;
    private rebalance;
    protected removeChild(child: ImageNode): void;
    remove(): void;
    renderAllAsync(renderer: AbstractRenderer, preRenderComponent: PreRenderComponentCallback): Promise<boolean>;
    render(renderer: AbstractRenderer, visibleRect?: Rect2): void;
    renderDebugBoundingBoxes(renderer: AbstractRenderer, visibleRect: Rect2, depth?: number): void;
    private checkRep;
}

type LoadSaveData = string[] | Record<symbol, string | number>;
type LoadSaveDataTable = Record<string, Array<LoadSaveData>>;
type DeserializeCallback = (data: string) => AbstractComponent;
declare enum ComponentSizingMode {
    /** The default. The compnent gets its size from its bounding box. */
    BoundingBox = 0,
    /** Causes the component to fill the entire visible region of the screen */
    FillScreen = 1,
    /**
       * Displays the component anywhere (arbitrary location) on the
       * canvas. (Ignoring the bounding box).
       *
       * These components may be ignored unless a full render is done.
       *
       * Intended for compnents that need to be rendered on a full export,
       * but won't be visible to the user.
       *
       * For example, a metadata component.
       */
    Anywhere = 2
}
/**
 * A base class for everything that can be added to an {@link EditorImage}.
 *
 * In addition to the `abstract` methods, there are a few methods that should be
 * overridden when creating a selectable/erasable subclass:
 * - {@link keyPoints}: Overriding this may improve how the component interacts with the selection tool.
 * - {@link withRegionErased}: Override/implement this to allow the component to be partially erased
 *    by the partial stroke eraser.
 */
declare abstract class AbstractComponent {
    private readonly componentKind;
    protected lastChangedTime: number;
    /**
       * The bounding box of this component.
       * {@link getBBox}, by default, returns `contentBBox`.
       * This must be set by components.
       *
       * If this changes, {@link EditorImage.queueRerenderOf} should be called for
       * this object (provided that this object has been added to the editor.)
       *
       * **Note**: This value is ignored if {@link getSizingMode} returns `FillScreen`
       * or `FillImage`.
       */
    protected abstract contentBBox: Rect2;
    private zIndex;
    private id;
    private static zIndexCounter;
    protected constructor(componentKind: string, initialZIndex?: number);
    getId(): string;
    private static deserializationCallbacks;
    static registerComponent(componentKind: string, deserialize: DeserializeCallback | null): void;
    private loadSaveData;
    /**
       * Attach data that can be used while exporting the component (e.g. to SVG).
       *
       * This is intended for use by an {@link ImageLoader}.
       */
    attachLoadSaveData(key: string, data: LoadSaveData): void;
    /** See {@link attachLoadSaveData} */
    getLoadSaveData(): LoadSaveDataTable;
    getZIndex(): number;
    /**
       * @returns the bounding box of this. This can be a slight overestimate if doing so
       * 			significantly improves performance.
       */
    getBBox(): Rect2;
    /**
       * @returns the bounding box of this. Unlike `getBBox`, this should **not** be a rough estimate.
       */
    getExactBBox(): Rect2;
    /**
       * Returns information about how this component should be displayed
       * (e.g. fill the screen or get its size from {@link getBBox}).
       *
       * {@link EditorImage.queueRerenderOf} must be called to apply changes to
       * the output of this method if this component has already been added to an
       * {@link EditorImage}.
       */
    getSizingMode(): ComponentSizingMode;
    /**
       * **Optimization**
       *
       * Should return `true` if this component covers the entire `visibleRect`
       * and would prevent anything below this component from being visible.
       *
       * Should return `false` otherwise.
       */
    occludesEverythingBelowWhenRenderedInRect(_visibleRect: Rect2): boolean;
    /** Called when this component is added to the given image. */
    onAddToImage(_image: EditorImage): void;
    onRemoveFromImage(): void;
    /**
       * Renders this component onto the given `canvas`.
       *
       * If `visibleRect` is given, it should be the region of `canvas` that is visible --
       * rendering anything outside of `visibleRect` should have no visible effect on the
       * resultant image.
       *
       * For optimal performance, implementers should call `canvas.startObject` and `canvas.endObject`
       * before and after rendering.
       */
    abstract render(canvas: AbstractRenderer, visibleRect?: Rect2): void;
    /** @return true if `lineSegment` intersects this component. */
    abstract intersects(lineSegment: LineSegment2): boolean;
    /**
       * @returns true if this component intersects `rect` -- it is entirely contained
       *  within the rectangle or one of the rectangle's edges intersects this component.
       *
       * The default implementation assumes that `this.getExactBBox()` returns a tight bounding box
       * -- that any horiziontal/vertical line that intersects this' boounding box also
       * intersects a point in this component. If this is not the case, components must override
       * this function.
       */
    intersectsRect(rect: Rect2): boolean;
    /**
       * Returns a selection of points within this object. Each contiguous section
       * of this object should have a point in the returned array.
       *
       * Subclasses should override this method if the center of the bounding box is
       * not contained within the object.
       */
    keyPoints(): IVec2[];
    isSelectable(): boolean;
    isBackground(): boolean;
    getProportionalRenderingTime(): number;
    protected abstract applyTransformation(affineTransfm: Mat33): void;
    /**
       * Returns a command that, when applied, transforms this by [affineTransfm] and
       * updates the editor.
       *
       * The transformed component is also moved to the top (use
       * {@link AbstractComponent#setZIndexAndTransformBy} to avoid this behavior).
       */
    transformBy(affineTransfm: Mat33): SerializableCommand;
    setZIndex(newZIndex: number): SerializableCommand;
    /**
       * Combines {@link transformBy} and {@link setZIndex} into a single command.
       *
       * @param newZIndex - The z-index this component should have after applying this command.
       * @param originalZIndex - @internal The z-index the component should revert to after unapplying
       *                         this command.
       */
    setZIndexAndTransformBy(affineTransfm: Mat33, newZIndex: number, originalZIndex?: number): SerializableCommand;
    private static transformElementCommandId;
    private static TransformElementCommand;
    /**
       * @return a description that could be read by a screen reader
       *     (e.g. when adding/erasing the component)
       */
    abstract description(localizationTable: ImageComponentLocalization): string;
    protected abstract createClone(): AbstractComponent;
    clone(): AbstractComponent;
    /**
       * Creates a copy of this component with a particular `id`.
       * This is used internally by {@link Duplicate} when deserializing.
       *
       * @internal -- users of the library shouldn't need this.
       */
    cloneWithId(cloneId: string): AbstractComponent;
    /**
       * **Optional method**: Divides this component into sections roughly along the given path,
       * removing parts that are roughly within `shape`.
       *
       * **Notes**:
       * - A default implementation may be provided for this method in the future. Until then,
       *   this method is `undefined` if unsupported.
       *
       * `viewport` should be provided to determine how newly-added points should be rounded.
       */
    withRegionErased?(shape: Path, viewport: Viewport): AbstractComponent[];
    protected abstract serializeToJSON(): any[] | Record<string, any> | number | string | null;
    serialize(): {
        name: string;
        zIndex: number;
        id: string;
        loadSaveData: LoadSaveDataTable;
        data: string | number | any[] | Record<string, any>;
    };
    private static isNotDeserializable;
    static deserialize(json: any): AbstractComponent;
}

interface AboutDialogLink {
    kind: 'link';
    text: string;
    href: string;
}
interface AboutDialogEntry {
    heading: string | AboutDialogLink;
    text?: string;
    minimized?: boolean;
}

interface CustomFilePickerProps {
    setOnCancelCallback(onCancel: () => void): void;
}
type ShowCustomFilePickerCallback = (props: CustomFilePickerProps) => Promise<File[] | null>;

/**
 * Provides settings to an instance of an editor. See the Editor {@link Editor.constructor}.
 *
 * ## Example
 *
 * [[include:doc-pages/inline-examples/settings-example-1.md]]
 */
interface EditorSettings {
    /** Defaults to `RenderingMode.CanvasRenderer` */
    renderingMode: RenderingMode;
    /** Uses a default English localization if a translation is not given. */
    localization: Partial<EditorLocalization>;
    /**
       * `true` if touchpad/mousewheel scrolling should scroll the editor instead of the document.
       * This does not include pinch-zoom events.
       * Defaults to true.
       */
    wheelEventsEnabled: boolean | 'only-if-focused';
    /** Minimum zoom fraction (e.g. 0.5 → 50% zoom). Defaults to $2 \cdot 10^{-10}$. */
    minZoom: number;
    /** Maximum zoom fraction (e.g. 2 → 200% zoom). Defaults to $1 \cdot 10^{12}$. */
    maxZoom: number;
    /**
       * Overrides for keyboard shortcuts. For example,
       * ```ts
       * {
       * 	'some.shortcut.id': [ KeyBinding.keyboardShortcutFromString('ctrl+a') ],
       * 	'another.shortcut.id': [ ]
       * }
       * ```
       * where shortcut IDs map to lists of associated keybindings.
       *
       * @see
       * - {@link KeyBinding}
       * - {@link KeyboardShortcutManager}
       */
    keyboardShortcutOverrides: Record<string, Array<KeyBinding>>;
    /**
       * Provides a set of icons for the editor.
       *
       * See, for example, the `@easydrawer/material-icons` package.
       */
    iconProvider: IconProvider;
    /**
       * Additional messages to show in the "about" dialog.
       */
    notices: AboutDialogEntry[];
    /**
       * Information about the app/website easydrawer is running within. This is shown
       * at the beginning of the about dialog.
       */
    appInfo: {
        name: string;
        description?: string;
        version?: string;
    } | null;
    /**
       * Configures the default {@link PenTool} tools.
       *
       * **Example**:
       * [[include:doc-pages/inline-examples/editor-settings-polyline-pen.md]]
       */
    pens: {
        /**
             * Additional pen types that can be selected in a toolbar.
             */
        additionalPenTypes?: readonly Readonly<PenTypeRecord>[];
        /**
             * Should return `true` if a pen type should be shown in the toolbar.
             *
             * @example
             * ```ts,runnable
             * import {Editor} from 'easydrawer';
             * const editor = new Editor(document.body, {
             *   // Only allow selecting the polyline pen from the toolbar.
             *   pens: { filterPenTypes: p => p.id === 'polyline-pen' },
             * });
             * editor.addToolbar();
             * ```
             * Notice that this setting only affects the toolbar GUI.
             */
        filterPenTypes?: (penType: PenTypeRecord) => boolean;
    } | null;
    /** Configures the default {@link TextTool} control and text tool. */
    text: {
        /** Fonts to show in the text UI. */
        fonts?: string[];
    } | null;
    /** Configures the default {@link InsertImageWidget} control. */
    image: {
        /**
             * A custom callback to show an image picker. If given, this should return
             * a list of `File`s representing the images selected by the picker.
             *
             * If not given, the default file picker shown by a [file input](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file)
             * is shown.
             */
        showImagePicker?: ShowCustomFilePickerCallback;
    } | null;
    /**
       * Allows changing how easydrawer interacts with the clipboard.
       *
       * **Note**: Even when a custom `clipboardApi` is specified, if a `ClipboardEvent` is available
       * (e.g. from when a user pastes with ctrl+v), the `ClipboardEvent` will be preferred.
       */
    clipboardApi: {
        /** Called to read data to the clipboard. Keys in the result are MIME types. Values are the data associated with that type. */
        read(): Promise<Map<string, Blob | string>>;
        /** Called to write data to the clipboard. Keys in `data` are MIME types. Values are the data associated with that type. */
        write(data: Map<string, Blob | Promise<Blob> | string>): void | Promise<void>;
    } | null;
    svg: {
        /** Plugins that create custom components while loading with {@link Editor.loadFromSVG}. */
        loaderPlugins?: SVGLoaderPlugin[];
    } | null;
    disableZoom: boolean;
}
/**
 * The main entrypoint for the full editor.
 *
 * ## Example
 * To create an editor with a toolbar,
 * ```ts,runnable
 * import { Editor } from 'easydrawer';
 *
 * const editor = new Editor(document.body);
 *
 * const toolbar = editor.addToolbar();
 * toolbar.addSaveButton(() => {
 *   const saveData = editor.toSVG().outerHTML;
 *   // Do something with saveData...
 * });
 * ```
 *
 * See also
 * * [`examples.md`](https://github.com/personalizedrefrigerator/easydrawer/blob/main/docs/examples.md).
 */
declare class Editor {
    private container;
    private renderingRegion;
    /** Manages drawing surfaces/{@link AbstractRenderer}s. */
    display: Display;
    /**
       * Handles undo/redo.
       *
       * @example
       * ```
       * const editor = new Editor(document.body);
       *
       * // Do something undoable.
       * // ...
       *
       * // Undo the last action
       * editor.history.undo();
       * ```
       */
    history: UndoRedoHistory;
    /**
       * Data structure for adding/removing/querying objects in the image.
       *
       * @example
       * ```ts,runnable
       * import { Editor, Stroke, Path, Color4, pathToRenderable } from 'easydrawer';
       * const editor = new Editor(document.body);
       *
       * // Create a path.
       * const stroke = new Stroke([
       *   pathToRenderable(Path.fromString('M0,0 L100,100 L300,30 z'), { fill: Color4.red }),
       * ]);
       * const addComponentCommand = editor.image.addComponent(stroke);
       *
       * // Add the stroke to the editor
       * editor.dispatch(addComponentCommand);
       * ```
       */
    readonly image: EditorImage;
    /**
       * Allows transforming the view and querying information about
       * what is currently visible.
       */
    readonly viewport: Viewport;
    /** @internal */
    readonly localization: EditorLocalization;
    /** {@link EditorSettings.iconProvider} */
    readonly icons: IconProvider;
    /**
       * Manages and allows overriding of keyboard shortcuts.
       *
       * @internal
       */
    readonly shortcuts: KeyboardShortcutManager;
    /**
       * Controls the list of tools. See
       * [the custom tool example](https://github.com/personalizedrefrigerator/easydrawer/tree/main/docs/examples/example-custom-tools)
       * for more.
       */
    readonly toolController: ToolController;
    /**
       * Global event dispatcher/subscriber.
       *
       * @example
       *
       * ```ts,runnable
       * import { Editor, EditorEventType, SerializableCommand } from 'easydrawer';
       *
       * // Create a minimal editor
       * const editor = new Editor(document.body);
       * editor.addToolbar();
       *
       * // Create a place to show text output
       * const log = document.createElement('textarea');
       * document.body.appendChild(log);
       * log.style.width = '100%';
       * log.style.height = '200px';
       *
       * // Listen for CommandDone events (there's also a CommandUndone)
       * editor.notifier.on(EditorEventType.CommandDone, event => {
       *   // Type narrowing for TypeScript -- event will always be of kind CommandDone,
       *   // but TypeScript doesn't know this.
       *   if (event.kind !== EditorEventType.CommandDone) return;
       *
       *   log.value = `Command done ${event.command.description(editor, editor.localization)}\n`;
       *
       *   if (event.command instanceof SerializableCommand) {
       *     log.value += `serializes to: ${JSON.stringify(event.command.serialize())}`;
       *   }
       * });
       *
       * // Dispatch an initial command to trigger the event listener for the first time
       * editor.dispatch(editor.image.setAutoresizeEnabled(true));
       * ```
       */
    readonly notifier: EditorNotifier;
    private loadingWarning;
    private accessibilityAnnounceArea;
    private accessibilityControlArea;
    private eventListenerTargets;
    private readOnly;
    private readonly settings;
    /**
       * @example
       * ```ts,runnable
       * import { Editor } from 'easydrawer';
       *
       * const container = document.body;
       *
       * // Create an editor
       * const editor = new Editor(container, {
       *   // 2e-10 and 1e12 are the default values for minimum/maximum zoom.
       *   minZoom: 2e-10,
       *   maxZoom: 1e12,
       * });
       *
       * // Add the default toolbar
       * const toolbar = editor.addToolbar();
       *
       * const createCustomIcon = () => {
       *   // Create/return an icon here.
       * };
       *
       * // Add a custom button
       * toolbar.addActionButton({
       *   label: 'Custom Button'
       *   icon: createCustomIcon(),
       * }, () => {
       *   // Do something here
       * });
       * ```
       */
    constructor(parent: HTMLElement, settings?: Partial<EditorSettings>);
    /**
       * @returns a shallow copy of the current settings of the editor.
       *
       * Do not modify.
       */
    getCurrentSettings(): Readonly<EditorSettings>;
    /**
       * @returns a reference to the editor's container.
       *
       * @example
       * ```
       *   // Set the editor's height to 500px
       *   editor.getRootElement().style.height = '500px';
       * ```
       */
    getRootElement(): HTMLElement;
    /**
       * @returns the bounding box of the main rendering region of the editor in the HTML viewport.
       *
       * @internal
       */
    getOutputBBoxInDOM(): Rect2;
    /**
       * Shows a "Loading..." message.
       * @param fractionLoaded - should be a number from 0 to 1, where 1 represents completely loaded.
       */
    showLoadingWarning(fractionLoaded: number): void;
    /** @see {@link showLoadingWarning} */
    hideLoadingWarning(): void;
    private previousAccessibilityAnnouncement;
    /**
       * Announce `message` for screen readers. If `message` is the same as the previous
       * message, it is re-announced.
       */
    announceForAccessibility(message: string): void;
    /**
       * Creates a toolbar. If `defaultLayout` is true, default buttons are used.
       * @returns a reference to the toolbar.
       */
    addToolbar(defaultLayout?: boolean): AbstractToolbar;
    private registerListeners;
    private updateEditorSizeVariables;
    /** @internal */
    handleHTMLWheelEvent(event: WheelEvent): boolean | undefined;
    private pointers;
    private getPointerList;
    /**
       * A protected method that can override setPointerCapture in environments where it may fail
       * (e.g. with synthetic events). @internal
       */
    protected setPointerCapture(target: HTMLElement, pointerId: number): void;
    /** Can be overridden in a testing environment to handle synthetic events. @internal */
    protected releasePointerCapture(target: HTMLElement, pointerId: number): void;
    /**
       * Dispatches a `PointerEvent` to the editor. The target element for `evt` must have the same top left
       * as the content of the editor.
       */
    handleHTMLPointerEvent(eventType: 'pointerdown' | 'pointermove' | 'pointerup' | 'pointercancel', evt: PointerEvent): boolean;
    private isEventSink;
    /** @internal */
    protected handleDrop(evt: DragEvent | ClipboardEvent): Promise<void>;
    /** @internal */
    protected handlePaste(evt: DragEvent | ClipboardEvent): Promise<boolean | undefined>;
    /**
       * Forward pointer events from `elem` to this editor. Such that right-click/right-click drag
       * events are also forwarded, `elem`'s contextmenu is disabled.
       *
       * `filter` is called once per pointer event, before doing any other processing. If `filter` returns `true` the event is
       * forwarded to the editor.
       *
       * **Note**: `otherEventsFilter` is like `filter`, but is called for other pointer-related
       * events that could also be forwarded to the editor. To forward just pointer events,
       * for example, `otherEventsFilter` could be given as `()=>false`.
       *
       * @example
       * ```ts
       * const overlay = document.createElement('div');
       * editor.createHTMLOverlay(overlay);
       *
       * // Send all pointer events that don't have the control key pressed
       * // to the editor.
       * editor.handlePointerEventsFrom(overlay, (event) => {
       *   if (event.ctrlKey) {
       *     return false;
       *   }
       *   return true;
       * });
       * ```
       */
    handlePointerEventsFrom(elem: HTMLElement, filter?: HTMLPointerEventFilter, otherEventsFilter?: (eventName: string, event: Event) => boolean): {
        /** Remove all event listeners registered by this function. */
        remove: () => void;
    };
    /**
       * Like {@link handlePointerEventsFrom} except ignores short input gestures like clicks.
       *
       * `filter` is called once per event, before doing any other processing. If `filter` returns `true` the event is
       * forwarded to the editor.
       *
       * `otherEventsFilter` is passed unmodified to `handlePointerEventsFrom`.
       */
    handlePointerEventsExceptClicksFrom(elem: HTMLElement, filter?: HTMLPointerEventFilter, otherEventsFilter?: (eventName: string, event: Event) => boolean): {
        /** Remove all event listeners registered by this function. */
        remove: () => void;
    };
    /** @internal */
    handleHTMLKeyDownEvent(htmlEvent: KeyboardEvent): boolean;
    /** @internal */
    handleHTMLKeyUpEvent(htmlEvent: KeyboardEvent): boolean;
    /**
       * Adds event listners for keypresses (and drop events) on `elem` and forwards those
       * events to the editor.
       *
       * If the given `filter` returns `false` for an event, the event is ignored and not
       * passed to the editor.
       */
    handleKeyEventsFrom(elem: HTMLElement, filter?: (event: KeyboardEvent) => boolean): void;
    /**
       * Attempts to prevent **user-triggered** events from modifying
       * the content of the image.
       */
    setReadOnly(readOnly: boolean): void;
    isReadOnlyReactiveValue(): ReactiveValue<boolean>;
    isReadOnly(): MutableReactiveValue<boolean>;
    /**
       * `apply` a command. `command` will be announced for accessibility.
       *
       * **Example**:
       * [[include:doc-pages/inline-examples/adding-a-stroke.md]]
       */
    dispatch(command: Command, addToHistory?: boolean): void | Promise<void>;
    /**
       * Dispatches a command without announcing it. By default, does not add to history.
       * Use this to show finalized commands that don't need to have `announceForAccessibility`
       * called.
       *
       * If `addToHistory` is `false`, this is equivalent to `command.apply(editor)`.
       *
       * @example
       * ```
       * const addToHistory = false;
       * editor.dispatchNoAnnounce(editor.viewport.zoomTo(someRectangle), addToHistory);
       * ```
       */
    dispatchNoAnnounce(command: Command, addToHistory?: boolean): void | Promise<void>;
    /**
       * Apply a large transformation in chunks.
       * If `apply` is `false`, the commands are unapplied.
       * Triggers a re-render after each `updateChunkSize`-sized group of commands
       * has been applied.
       */
    asyncApplyOrUnapplyCommands(commands: Command[], apply: boolean, updateChunkSize: number): Promise<void>;
    /** @see {@link asyncApplyOrUnapplyCommands } */
    asyncApplyCommands(commands: Command[], chunkSize: number): Promise<void>;
    /**
       * @see {@link asyncApplyOrUnapplyCommands}
       *
       * If `unapplyInReverseOrder`, commands are reversed before unapplying.
       */
    asyncUnapplyCommands(commands: Command[], chunkSize: number, unapplyInReverseOrder?: boolean): Promise<void>;
    private announceUndoCallback;
    private announceRedoCallback;
    private nextRerenderListeners;
    private rerenderQueued;
    /**
       * Schedule a re-render for some time in the near future. Does not schedule an additional
       * re-render if a re-render is already queued.
       *
       * @returns a promise that resolves when re-rendering has completed.
       */
    queueRerender(): Promise<void>;
    isRerenderQueued(): boolean;
    /**
       * Re-renders the entire image.
       *
       * @see {@link Editor.queueRerender}
       */
    rerender(showImageBounds?: boolean): void;
    /**
       * Draws the given path onto the wet ink renderer. The given path will
       * be displayed on top of the main image.
       *
       * @see {@link Display.getWetInkRenderer} {@link Display.flatten}
       */
    drawWetInk(...path: RenderablePathSpec[]): void;
    /**
       * Clears the wet ink display.
       *
       * The wet ink display can be used by the currently active tool to display a preview
       * of an in-progress action.
       *
       * @see {@link Display.getWetInkRenderer}
       */
    clearWetInk(): void;
    /**
       * Focuses the region used for text input/key commands.
       */
    focus(): void;
    /**
       * Creates an element that will be positioned on top of the dry/wet ink
       * renderers.
       *
       * So as not to change the position of other overlays, `overlay` should either
       * be styled to have 0 height or have `position: absolute`.
       *
       * This is useful for displaying content on top of the rendered content
       * (e.g. a selection box).
       */
    createHTMLOverlay(overlay: HTMLElement): {
        remove: () => void;
    };
    /**
       * Anchors the given `element` to the canvas with a given position/transformation in canvas space.
       */
    anchorElementToCanvas(element: HTMLElement, canvasTransform: Mat33 | ReactiveValue<Mat33>): {
        remove: () => void;
    };
    /**
       * Creates a CSS stylesheet with `content` and applies it to the document
       * (and thus, to this editor).
       */
    addStyleSheet(content: string): HTMLStyleElement;
    /**
       * Dispatch a keyboard event to the currently selected tool.
       * Intended for unit testing.
       *
       * If `shiftKey` is undefined, it is guessed from `key`.
       *
       * At present, the **key code** dispatched is guessed from the given key and,
       * while this works for ASCII alphanumeric characters, this does not work for
       * most non-alphanumeric keys.
       *
       * Because guessing the key code from `key` is problematic, **only use this for testing**.
       */
    sendKeyboardEvent(eventType: InputEvtType.KeyPressEvent | InputEvtType.KeyUpEvent, key: string, ctrlKey?: boolean, altKey?: boolean, shiftKey?: boolean | undefined): void;
    /**
       * Dispatch a pen event to the currently selected tool.
       * Intended primarially for unit tests.
       *
       * @deprecated
       * @see {@link sendPenEvent} {@link sendTouchEvent}
       */
    sendPenEvent(eventType: PointerEvtType, point: IVec2, allPointers?: Pointer[]): void;
    /**
       * Adds all components in `components` such that they are in the center of the screen.
       * This is a convenience method that creates **and applies** a single command.
       *
       * If `selectComponents` is true (the default), the components are selected.
       *
       * `actionDescription`, if given, should be a screenreader-friendly description of the
       * reason components were added (e.g. "pasted").
       */
    addAndCenterComponents(components: AbstractComponent[], selectComponents?: boolean, actionDescription?: string): Promise<void>;
    /**
       * Get a data URL (e.g. as produced by `HTMLCanvasElement::toDataURL`).
       * If `format` is not `image/png`, a PNG image URL may still be returned (as in the
       * case of `HTMLCanvasElement::toDataURL`).
       *
       * The export resolution is the same as the size of the drawing canvas, unless `outputSize`
       * is given.
       *
       * **Example**:
       * [[include:doc-pages/inline-examples/adding-an-image-and-data-urls.md]]
       */
    toDataURL(format?: 'image/png' | 'image/jpeg' | 'image/webp', outputSize?: IVec2): string;
    /**
       * Converts the editor's content into an SVG image.
       *
       * If the output SVG has width or height less than `options.minDimension`, its size
       * will be increased.
       *
       * @see
       * {@link SVGRenderer}
       */
    toSVG(options?: {
        minDimension?: number;
    }): SVGElement;
    /**
       * Converts the editor's content into an SVG image in an asynchronous,
       * but **potentially lossy** way.
       *
       * **Warning**: If the image is being edited during an async rendering, edited components
       * may not be rendered.
       *
       * Like {@link toSVG}, but can be configured to briefly pause after processing every
       * `pauseAfterCount` items. This can prevent the editor from becoming unresponsive
       * when saving very large images.
       */
    toSVGAsync(options?: {
        minDimension?: number;
        pauseAfterCount?: number;
        onProgress?: (processedCountInLayer: number, totalToProcessInLayer: number) => Promise<void | boolean>;
    }): Promise<SVGElement>;
    /**
       * Load editor data from an `ImageLoader` (e.g. an {@link SVGLoader}).
       *
       * @see loadFromSVG
       */
    loadFrom(loader: ImageLoader): Promise<void>;
    private getTopmostBackgroundComponent;
    /**
       * This is a convenience method for adding or updating the {@link BackgroundComponent}
       * and {@link EditorImage.setAutoresizeEnabled} for the current image.
       *
       * If there are multiple {@link BackgroundComponent}s in the image, this only modifies
       * the topmost such element.
       *
       * **Example**:
       * ```ts,runnable
       * import { Editor, Color4, BackgroundComponentBackgroundType } from 'easydrawer';
       * const editor = new Editor(document.body);
       * editor.dispatch(editor.setBackgroundStyle({
       *     color: Color4.orange,
       *     type: BackgroundComponentBackgroundType.Grid,
       *     autoresize: true,
       * }));
       * ```
       *
       * To change the background size, see {@link EditorImage.setImportExportRect}.
       */
    setBackgroundStyle(style: {
        color?: Color4;
        type?: BackgroundType;
        autoresize?: boolean;
    }): Command;
    /**
       * Set the background color of the image.
       *
       * This is a convenience method for adding or updating the {@link BackgroundComponent}
       * for the current image.
       *
       * @see {@link setBackgroundStyle}
       */
    setBackgroundColor(color: Color4): Command;
    /**
       * @returns the average of the colors of all background components. Use this to get the current background
       * color.
       */
    estimateBackgroundColor(): Color4;
    getImportExportRect(): Rect2;
    setImportExportRect(imageRect: Rect2): Command;
    /**
       * Alias for `loadFrom(SVGLoader.fromString)`.
       *
       * @example
       * ```ts,runnable
       * import {Editor} from 'easydrawer';
       * const editor = new Editor(document.body);
       *
       * ---visible---
       * await editor.loadFromSVG(`
       *   <svg viewBox="5 23 52 30" width="52" height="16" version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
       *     <text style="
       *       transform: matrix(0.181846, 0.1, 0, 0.181846, 11.4, 33.2);
       *       font-family: serif;
       *       font-size: 32px;
       *       fill: rgb(100, 140, 61);
       *     ">An SVG image!</text>
       *   </svg>
       * `);
       * ```
       */
    loadFromSVG(svgData: string, sanitize?: boolean): Promise<void>;
    private closeAboutDialog;
    /**
       * Shows an information dialog with legal notices.
       */
    showAboutDialog(): void;
    /**
       * Removes and **destroys** the editor. The editor cannot be added to a parent
       * again after calling this method.
       */
    remove(): void;
    uploadImages(files: File[]): Promise<void>;
}

export { Abstract2DShape, AbstractComponent, AbstractRenderer, AbstractToolbar, ActionButtonWidget, BackgroundComponent, BackgroundType as BackgroundComponentBackgroundType, BaseTool, BaseToolWidget, BaseWidget, CanvasRenderer, Color4, type ColorPickerColorSelected, type ColorPickerToggled, Command, type CommandDoneEvent, type CommandUndoneEvent, type ComponentAddedListener, type ComponentBuilder, type ComponentBuilderFactory, ComponentSizingMode, type ContextMenuEvt, type CopyEvent, type CubicBezierPathCommand, type DeserializeCallback, Display, type DisplayResizedEvent, DocumentPropertiesWidget, DummyRenderer, Duplicate, Editor, type EditorEventDataType, EditorEventType, EditorImage, type EditorLocalization, type EditorNotifier, type EditorObjectEvent, type EditorSettings, type EditorToolEvent, type EditorUndoStackUpdated, type EditorViewportChangedEvent, Erase, EraserMode, Eraser as EraserTool, EraserToolWidget, EventDispatcher, type GestureCancelEvt, type HTMLPointerEventFilter, type HTMLPointerEventName, AbstractToolbar as HTMLToolbar, HandToolWidget, type IVec2, type IVec3, type IconElemType, IconProvider, ImageComponent, type ImageLoader, type InputEvt, InputEvtType, InputMapper, InsertImageWidget, KeyBinding, type KeyPressEvent, type KeyUpEvent, KeyboardShortcutManager, type LinePathCommand, LineSegment2, type LoadSaveData, type LoadSaveDataTable, Mat33, type Mat33Array, type MoveToPathCommand, MutableReactiveValue, type OnDetermineExportRectListener, type OnProgressListener, PanZoomMode, PanZoom as PanZoomTool, Parameterized2DShape, type PasteEvent, PasteHandler, Path, type PathCommand, PathCommandType, type CurveIndexRecord as PathCurveIndex, type IntersectionResult as PathIntersectionResult, type PenStyle, Pen as PenTool, PenToolWidget, Pointer, PointerDevice, type PointerDownEvt, type PointerEvt, type PointerEvtListener, type PointerEvtType, type PointerMoveEvt, type PointerUpEvt, QuadraticBezier, type QuadraticBezierPathCommand, ReactiveValue, type ReadOnlyToggled, Rect2, type RenderablePathSpec, RenderingMode, type RenderingStyle, type RestyleableComponent, type ComponentStyle as RestyleableComponentStyle, SVGLoader, type SVGLoaderPlugin, SVGRenderer, SelectAllShortcutHandler, SelectionMode, SelectionTool, SelectionToolWidget, type SelectionUpdated, SerializableCommand, SoundUITool, Stroke, Stroke as StrokeComponent, type StrokeDataPoint, type StrokeStyle as StrokeRenerdingStyle, StrokeSmoother, type Curve as StrokeSmootherCurve, TextComponent as Text, TextComponent, type TextRenderingStyle, TextTool, TextToolWidget, ToolController, ToolEnabledGroup, ToolSwitcherShortcut, type ToolbarDropdownShownEvent, ToolbarShortcutHandler, ToolbarWidgetTag, Triangle, UndoEventType, UndoRedoHistory, UndoRedoShortcut, Vec2, Vec3, Viewport, type WheelEvt, _default as __easy_draw__version, adjustEditorThemeForContrast, compareCurveIndices as comparePathIndices, createRestyleComponentCommand, Editor as default, defaultEditorLocalization, getLocalizationTable, invertCommand, isPointerEvt, isRestylableComponent, keyPressEventFromHTMLEvent, keyUpEventFromHTMLEvent, makeArrowBuilder, makeCircleBuilder, makeColorInput, makeDropdownToolbar, makeEdgeToolbar, makeFilledRectangleBuilder, makeFreehandLineBuilder, makeLineBuilder, makeOutlinedRectangleBuilder, makePolylineBuilder, makePressureSensitiveFreehandLineBuilder, matchingLocalizationTable, pathFromRenderable, pathToRenderable, visualEquivalent as pathVisualEquivalent, sendPenEvent, sendTouchEvent, stepCurveIndexBy as stepPathIndexBy, toRoundedString, uniteCommands };
