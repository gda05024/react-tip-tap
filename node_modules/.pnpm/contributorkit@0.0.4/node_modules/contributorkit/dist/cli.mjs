import process from 'node:process';
import yargs from 'yargs';
import { S as SvgComposer, g as generateBadge, t as tierPresets, v as version, l as loadConfig, r as resolveAvatars, o as outputFormats, s as svgToPng, a as svgToWebp } from './shared/contributorkit.cea92471.mjs';
import { resolve, dirname, join, relative } from 'node:path';
import fs from 'node:fs';
import fsp from 'node:fs/promises';
import { consola } from 'consola';
import c from 'picocolors';
import { Octokit } from '@octokit/core';
import { Buffer } from 'node:buffer';
import 'ofetch';
import 'sharp';
import 'unconfig';

const circlesRenderer = {
  name: "contributorkit:circles",
  async renderSVG(config, contributors) {
    const { hierarchy, pack } = await import('d3-hierarchy');
    const composer = new SvgComposer(config);
    const amountMax = Math.max(...contributors.map((contributor) => contributor.contributions));
    const {
      radiusMax = 300,
      radiusMin = 10,
      radiusPast = 5,
      weightInterop = defaultInterop
    } = config.circles || {};
    function defaultInterop(contribute) {
      return contribute.contributions < 0 ? radiusPast : lerp(radiusMin, radiusMax, (Math.max(0.1, contribute.contributions || 0) / amountMax) ** 0.9);
    }
    const root = hierarchy({ ...contributors[0], children: contributors, id: "root" }).sum((d) => weightInterop(d, amountMax)).sort((a, b) => (b.value || 0) - (a.value || 0));
    const p = pack();
    p.size([config.width, config.width]);
    p.padding(config.width / 400);
    const circles = p(root).descendants().slice(1);
    for (const circle of circles) {
      composer.addRaw(await generateBadge(
        circle.x - circle.r,
        circle.y - circle.r,
        circle.data,
        {
          name: false,
          boxHeight: circle.r * 2,
          boxWidth: circle.r * 2,
          avatar: {
            size: circle.r * 2
          }
        },
        0.5,
        config.imageFormat
      ));
    }
    composer.height = config.width;
    return composer.generateSvg();
  }
};
function lerp(a, b, t) {
  if (t < 0)
    return a;
  return a + (b - a) * t;
}

function partitionTiers(contributions, tiers) {
  const tierMappings = tiers.map((tier) => ({
    contribution: tier.contribution ?? 0,
    tier,
    contributions: []
  }));
  tierMappings.sort((a, b) => b.contribution - a.contribution);
  contributions.filter((s) => s.contributions > 0).forEach((contributor) => {
    const tier = tierMappings.find((t) => contributor.contributions >= t.contribution) ?? tierMappings[0];
    tier.contributions.push(contributor);
  });
  return tierMappings;
}
async function tiersComposer(composer, contributors, config) {
  const tierPartitions = partitionTiers(contributors, config.tiers);
  composer.addSpan(config.padding?.top ?? 20);
  for (const { tier: t, contributions } of tierPartitions) {
    const preset = t.preset || tierPresets.base;
    if (contributions.length && preset.avatar.size) {
      const paddingTop = t.padding?.top ?? 20;
      const paddingBottom = t.padding?.bottom ?? 10;
      if (paddingTop)
        composer.addSpan(paddingTop);
      if (t.title) {
        composer.addTitle(t.title).addSpan(5);
      }
      await composer.addSponsorGrid(contributions, preset);
      if (paddingBottom)
        composer.addSpan(paddingBottom);
    }
  }
  composer.addSpan(config.padding?.bottom ?? 20);
}
const tiersRenderer = {
  name: "contributorkit:tiers",
  async renderSVG(config, contributors) {
    const composer = new SvgComposer(config);
    await (config.customComposer || tiersComposer)(composer, contributors, config);
    return composer.generateSvg();
  }
};

const builtinRenderers = {
  tiers: tiersRenderer,
  circles: circlesRenderer
};

function stringifyCache(cache) {
  return JSON.stringify(
    cache,
    (_key, value) => {
      if (value && value.type === "Buffer" && Array.isArray(value.data))
        return Buffer.from(value.data).toString("base64");
      return value;
    },
    2
  );
}
function parseCache(cache) {
  return JSON.parse(cache, (key, value) => {
    if (key === "avatarBuffer")
      return Buffer.from(value, "base64");
    return value;
  });
}

function r(path) {
  return `./${relative(process.cwd(), path)}`;
}
async function run(inlineConfig, t = consola) {
  t.log(`
${c.magenta(c.bold("ContributorKit"))} ${c.dim(`v${version}`)}
`);
  const fullConfig = await loadConfig(inlineConfig);
  const config = fullConfig;
  const dir = resolve(process.cwd(), config.outputDir);
  const cacheFile = resolve(dir, config.cacheFile);
  if (config.renders?.length) {
    const names = /* @__PURE__ */ new Set();
    config.renders.forEach((renderOptions, idx) => {
      const name = renderOptions.name || "contributors";
      if (names.has(name))
        throw new Error(`Duplicate render name: ${name} at index ${idx}`);
      names.add(name);
    });
  }
  let allContributors = [];
  const octokit = new Octokit();
  if (!config.owner || !config.repo)
    throw new Error("Missing owner or repo in config");
  if (!fs.existsSync(cacheFile)) {
    const res = await octokit.request(`GET /repos/${config.owner}/${config.repo}/contributors`, {
      owner: config.owner,
      repo: config.repo,
      per_page: 100
    });
    allContributors = res?.data?.filter((v) => v.type !== "Bot") || [];
    t.info("Resolving avatars...");
    await resolveAvatars(allContributors);
    t.success("Avatars resolved");
    await fsp.mkdir(dirname(cacheFile), { recursive: true });
    await fsp.writeFile(cacheFile, stringifyCache(allContributors));
  } else {
    allContributors = parseCache(await fsp.readFile(cacheFile, "utf-8"));
    t.success(`Loaded from cache ${r(cacheFile)}`);
  }
  allContributors.sort(
    (a, b) => b.contributions - a.contributions || b.login.localeCompare(a.login)
    // ASC name
  );
  if (config.renders?.length) {
    t.info(`Generating with ${config.renders.length} renders...`);
    await Promise.all(config.renders.map(async (renderOptions) => {
      const mergedOptions = {
        ...fullConfig,
        ...renderOptions
      };
      const renderer = builtinRenderers[mergedOptions.renderer || "tiers"];
      await applyRenderer(
        renderer,
        config,
        // @ts-expect-error
        mergedOptions,
        allContributors,
        t
      );
    }));
  } else {
    const renderer = builtinRenderers[fullConfig.renderer || "tiers"];
    await applyRenderer(
      renderer,
      config,
      // @ts-expect-error
      fullConfig,
      allContributors,
      t
    );
  }
}
async function applyRenderer(renderer, config, renderOptions, contributors, t = consola) {
  const logPrefix = c.dim(`[${renderOptions.name}]`);
  const dir = resolve(process.cwd(), config.outputDir);
  await fsp.mkdir(dir, { recursive: true });
  if (!renderOptions.imageFormat)
    renderOptions.imageFormat = "webp";
  t.info(`${logPrefix} Composing SVG...`);
  const processingSvg = (async () => {
    let svgWebp = await renderer.renderSVG(renderOptions, contributors);
    if (renderOptions.onSvgGenerated)
      svgWebp = await renderOptions.onSvgGenerated(svgWebp) || svgWebp;
    return svgWebp;
  })();
  if (renderOptions.formats) {
    let svgPng;
    await Promise.all([
      renderOptions.formats.map(async (format) => {
        if (!outputFormats.includes(format))
          throw new Error(`Unsupported format: ${format}`);
        const path = join(dir, `${renderOptions.name}.${format}`);
        let data;
        if (format === "svg")
          data = await processingSvg;
        if (format === "png" || format === "webp") {
          if (!svgPng) {
            svgPng = renderer.renderSVG({
              ...renderOptions,
              imageFormat: "png"
            }, contributors);
          }
          if (format === "png")
            data = await svgToPng(await svgPng);
          if (format === "webp")
            data = await svgToWebp(await svgPng);
        }
        await fsp.writeFile(path, data);
        t.success(`${logPrefix} Wrote to ${r(path)}`);
      })
    ]);
  }
}

const cli = yargs(process.argv.slice(2)).scriptName("contributors-svg").usage("$0 [args]").version(version).strict().showHelpOnFail(false).alias("h", "help").alias("v", "version");
cli.command(
  "*",
  "Generate",
  (args) => args.option("owner", {
    type: "string",
    requiresArg: true
  }).option("repo", {
    type: "string",
    requiresArg: true
  }).option("width", {
    alias: "w",
    type: "number",
    default: 800
  }).option("outputDir", {
    type: "string",
    alias: ["out", "dir"]
  }).option("renderer", {
    type: "string",
    description: "tiers | circles",
    default: "tiers"
  }).option("name", {
    type: "string"
  }).option("format", {
    type: "string",
    default: "svg"
  }).strict().help(),
  async (options) => {
    const config = options;
    if (options._[0])
      config.outputDir = options._[0];
    await run(config);
  }
);
cli.help().parse();
