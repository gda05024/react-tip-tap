var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/.pnpm/picocolors@1.1.1/node_modules/picocolors/picocolors.js
var require_picocolors = __commonJS({
  "node_modules/.pnpm/picocolors@1.1.1/node_modules/picocolors/picocolors.js"(exports2, module2) {
    var p = process || {};
    var argv = p.argv || [];
    var env = p.env || {};
    var isColorSupported = !(!!env.NO_COLOR || argv.includes("--no-color")) && (!!env.FORCE_COLOR || argv.includes("--color") || p.platform === "win32" || (p.stdout || {}).isTTY && env.TERM !== "dumb" || !!env.CI);
    var formatter = (open, close, replace = open) => (input) => {
      let string = "" + input, index = string.indexOf(close, open.length);
      return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
    };
    var replaceClose = (string, close, replace, index) => {
      let result = "", cursor = 0;
      do {
        result += string.substring(cursor, index) + replace;
        cursor = index + close.length;
        index = string.indexOf(close, cursor);
      } while (~index);
      return result + string.substring(cursor);
    };
    var createColors = (enabled = isColorSupported) => {
      let f = enabled ? formatter : () => String;
      return {
        isColorSupported: enabled,
        reset: f("\x1B[0m", "\x1B[0m"),
        bold: f("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
        dim: f("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
        italic: f("\x1B[3m", "\x1B[23m"),
        underline: f("\x1B[4m", "\x1B[24m"),
        inverse: f("\x1B[7m", "\x1B[27m"),
        hidden: f("\x1B[8m", "\x1B[28m"),
        strikethrough: f("\x1B[9m", "\x1B[29m"),
        black: f("\x1B[30m", "\x1B[39m"),
        red: f("\x1B[31m", "\x1B[39m"),
        green: f("\x1B[32m", "\x1B[39m"),
        yellow: f("\x1B[33m", "\x1B[39m"),
        blue: f("\x1B[34m", "\x1B[39m"),
        magenta: f("\x1B[35m", "\x1B[39m"),
        cyan: f("\x1B[36m", "\x1B[39m"),
        white: f("\x1B[37m", "\x1B[39m"),
        gray: f("\x1B[90m", "\x1B[39m"),
        bgBlack: f("\x1B[40m", "\x1B[49m"),
        bgRed: f("\x1B[41m", "\x1B[49m"),
        bgGreen: f("\x1B[42m", "\x1B[49m"),
        bgYellow: f("\x1B[43m", "\x1B[49m"),
        bgBlue: f("\x1B[44m", "\x1B[49m"),
        bgMagenta: f("\x1B[45m", "\x1B[49m"),
        bgCyan: f("\x1B[46m", "\x1B[49m"),
        bgWhite: f("\x1B[47m", "\x1B[49m"),
        blackBright: f("\x1B[90m", "\x1B[39m"),
        redBright: f("\x1B[91m", "\x1B[39m"),
        greenBright: f("\x1B[92m", "\x1B[39m"),
        yellowBright: f("\x1B[93m", "\x1B[39m"),
        blueBright: f("\x1B[94m", "\x1B[39m"),
        magentaBright: f("\x1B[95m", "\x1B[39m"),
        cyanBright: f("\x1B[96m", "\x1B[39m"),
        whiteBright: f("\x1B[97m", "\x1B[39m"),
        bgBlackBright: f("\x1B[100m", "\x1B[49m"),
        bgRedBright: f("\x1B[101m", "\x1B[49m"),
        bgGreenBright: f("\x1B[102m", "\x1B[49m"),
        bgYellowBright: f("\x1B[103m", "\x1B[49m"),
        bgBlueBright: f("\x1B[104m", "\x1B[49m"),
        bgMagentaBright: f("\x1B[105m", "\x1B[49m"),
        bgCyanBright: f("\x1B[106m", "\x1B[49m"),
        bgWhiteBright: f("\x1B[107m", "\x1B[49m")
      };
    };
    module2.exports = createColors();
    module2.exports.createColors = createColors;
  }
});

// src/cli.ts
var cli_exports = {};
__export(cli_exports, {
  checkGitStatus: () => checkGitStatus,
  main: () => main
});
module.exports = __toCommonJS(cli_exports);

// src/cli/index.ts
var import_node_process7 = __toESM(require("process"), 1);

// node_modules/.pnpm/log-symbols@7.0.0/node_modules/log-symbols/symbols.js
var symbols_exports = {};
__export(symbols_exports, {
  error: () => error,
  info: () => info,
  success: () => success,
  warning: () => warning
});

// node_modules/.pnpm/yoctocolors@2.1.1/node_modules/yoctocolors/base.js
var import_node_tty = __toESM(require("tty"), 1);
var hasColors = import_node_tty.default?.WriteStream?.prototype?.hasColors?.() ?? false;
var format = (open, close) => {
  if (!hasColors) {
    return (input) => input;
  }
  const openCode = `\x1B[${open}m`;
  const closeCode = `\x1B[${close}m`;
  return (input) => {
    const string = input + "";
    let index = string.indexOf(closeCode);
    if (index === -1) {
      return openCode + string + closeCode;
    }
    let result = openCode;
    let lastIndex = 0;
    while (index !== -1) {
      result += string.slice(lastIndex, index) + openCode;
      lastIndex = index + closeCode.length;
      index = string.indexOf(closeCode, lastIndex);
    }
    result += string.slice(lastIndex) + closeCode;
    return result;
  };
};
var reset = format(0, 0);
var bold = format(1, 22);
var dim = format(2, 22);
var italic = format(3, 23);
var underline = format(4, 24);
var overline = format(53, 55);
var inverse = format(7, 27);
var hidden = format(8, 28);
var strikethrough = format(9, 29);
var black = format(30, 39);
var red = format(31, 39);
var green = format(32, 39);
var yellow = format(33, 39);
var blue = format(34, 39);
var magenta = format(35, 39);
var cyan = format(36, 39);
var white = format(37, 39);
var gray = format(90, 39);
var bgBlack = format(40, 49);
var bgRed = format(41, 49);
var bgGreen = format(42, 49);
var bgYellow = format(43, 49);
var bgBlue = format(44, 49);
var bgMagenta = format(45, 49);
var bgCyan = format(46, 49);
var bgWhite = format(47, 49);
var bgGray = format(100, 49);
var redBright = format(91, 39);
var greenBright = format(92, 39);
var yellowBright = format(93, 39);
var blueBright = format(94, 39);
var magentaBright = format(95, 39);
var cyanBright = format(96, 39);
var whiteBright = format(97, 39);
var bgRedBright = format(101, 49);
var bgGreenBright = format(102, 49);
var bgYellowBright = format(103, 49);
var bgBlueBright = format(104, 49);
var bgMagentaBright = format(105, 49);
var bgCyanBright = format(106, 49);
var bgWhiteBright = format(107, 49);

// node_modules/.pnpm/is-unicode-supported@2.1.0/node_modules/is-unicode-supported/index.js
var import_node_process = __toESM(require("process"), 1);
function isUnicodeSupported() {
  const { env } = import_node_process.default;
  const { TERM, TERM_PROGRAM } = env;
  if (import_node_process.default.platform !== "win32") {
    return TERM !== "linux";
  }
  return Boolean(env.WT_SESSION) || Boolean(env.TERMINUS_SUBLIME) || env.ConEmuTask === "{cmd::Cmder}" || TERM_PROGRAM === "Terminus-Sublime" || TERM_PROGRAM === "vscode" || TERM === "xterm-256color" || TERM === "alacritty" || TERM === "rxvt-unicode" || TERM === "rxvt-unicode-256color" || env.TERMINAL_EMULATOR === "JetBrains-JediTerm";
}

// node_modules/.pnpm/log-symbols@7.0.0/node_modules/log-symbols/symbols.js
var _isUnicodeSupported = isUnicodeSupported();
var info = blue(_isUnicodeSupported ? "\u2139" : "i");
var success = green(_isUnicodeSupported ? "\u2714" : "\u221A");
var warning = yellow(_isUnicodeSupported ? "\u26A0" : "\u203C");
var error = red(_isUnicodeSupported ? "\u2716\uFE0F" : "\xD7");

// src/cli/index.ts
var import_tinyexec4 = require("tinyexec");

// src/version-bump.ts
var import_node_process4 = __toESM(require("process"), 1);

// node_modules/.pnpm/args-tokenizer@0.3.0/node_modules/args-tokenizer/dist/args-tokenizer.js
var spaceRegex = /\s/;
var tokenizeArgs = (argsString, options) => {
  const tokens = [];
  let currentToken = "";
  let openningQuote;
  let escaped = false;
  for (let index = 0; index < argsString.length; index += 1) {
    const char = argsString[index];
    if (escaped) {
      escaped = false;
      if (openningQuote || char !== "\n") {
        currentToken += char;
      }
      continue;
    }
    if (char === "\\") {
      escaped = true;
      continue;
    }
    if (openningQuote === void 0 && spaceRegex.test(char)) {
      if (currentToken.length > 0) {
        tokens.push(currentToken);
        currentToken = "";
      }
      continue;
    }
    if (char === "'" || char === '"') {
      if (openningQuote === void 0) {
        openningQuote = char;
        continue;
      }
      if (openningQuote === char) {
        openningQuote = void 0;
        continue;
      }
    }
    currentToken += char;
  }
  if (currentToken.length > 0) {
    tokens.push(currentToken);
  }
  if (options?.loose) {
    return tokens;
  }
  if (openningQuote) {
    throw Error("Unexpected end of string. Closing quote is missing.");
  }
  return tokens;
};

// src/version-bump.ts
var import_picocolors3 = __toESM(require_picocolors(), 1);
var import_prompts2 = __toESM(require("prompts"), 1);
var import_tiny_conventional_commits_parser = require("tiny-conventional-commits-parser");
var import_tinyexec3 = require("tinyexec");

// src/get-current-version.ts
var import_semver = require("semver");

// src/fs.ts
var import_node_fs = __toESM(require("fs"), 1);
var import_node_path = __toESM(require("path"), 1);
var jsonc = __toESM(require("jsonc-parser"), 1);
async function readJsoncFile(name, cwd) {
  const file = await readTextFile(name, cwd);
  const data = jsonc.parse(file.data);
  const modified = [];
  return { ...file, data, modified, text: file.data };
}
async function writeJsoncFile(file) {
  let newJSON = file.text;
  for (const [key, value] of file.modified) {
    const edit = jsonc.modify(newJSON, key, value, {});
    newJSON = jsonc.applyEdits(newJSON, edit);
  }
  return writeTextFile({ ...file, data: newJSON });
}
function readTextFile(name, cwd) {
  return new Promise((resolve, reject) => {
    const filePath = import_node_path.default.join(cwd, name);
    import_node_fs.default.readFile(filePath, "utf8", (err, text) => {
      if (err) {
        reject(err);
      } else {
        resolve({
          path: filePath,
          data: text
        });
      }
    });
  });
}
function writeTextFile(file) {
  return new Promise((resolve, reject) => {
    import_node_fs.default.writeFile(file.path, file.data, (err) => {
      if (err)
        reject(err);
      else
        resolve();
    });
  });
}

// src/manifest.ts
function isManifest(obj) {
  return obj && typeof obj === "object" && isOptionalString(obj.name) && isOptionalString(obj.version) && isOptionalString(obj.description);
}
function isPackageLockManifest(manifest) {
  return typeof manifest.packages?.[""]?.version === "string";
}
function isOptionalString(value) {
  const type = typeof value;
  return value === null || type === "undefined" || type === "string";
}

// src/get-current-version.ts
async function getCurrentVersion(operation) {
  if (operation.state.currentVersion)
    return operation;
  const { cwd, files } = operation.options;
  const filesToCheck = files.filter((file) => file.endsWith(".json"));
  if (!filesToCheck.includes("package.json"))
    filesToCheck.push("package.json");
  if (!filesToCheck.includes("deno.json"))
    filesToCheck.push("deno.json");
  if (!filesToCheck.includes("deno.jsonc"))
    filesToCheck.push("deno.jsonc");
  for (const file of filesToCheck) {
    const version2 = await readVersion(file, cwd);
    if (version2) {
      return operation.update({
        currentVersionSource: file,
        currentVersion: version2
      });
    }
  }
  throw new Error(
    `Unable to determine the current version number. Checked ${filesToCheck.join(", ")}.`
  );
}
async function readVersion(file, cwd) {
  try {
    const { data: manifest } = await readJsoncFile(file, cwd);
    if (isManifest(manifest)) {
      if ((0, import_semver.valid)(manifest.version))
        return manifest.version;
    }
  } catch {
    return void 0;
  }
}

// src/get-new-version.ts
var import_node_process2 = __toESM(require("process"), 1);
var import_picocolors = __toESM(require_picocolors(), 1);
var import_prompts = __toESM(require("prompts"), 1);
var import_semver2 = __toESM(require("semver"), 1);

// src/release-type.ts
var prereleaseTypes = ["premajor", "preminor", "prepatch", "prerelease"];
var releaseTypes = prereleaseTypes.concat(["major", "minor", "patch", "next", "conventional"]);
function isPrerelease(value) {
  return prereleaseTypes.includes(value);
}
function isReleaseType(value) {
  return releaseTypes.includes(value);
}

// src/get-new-version.ts
async function getNewVersion(operation, commits) {
  const { release } = operation.options;
  const { currentVersion } = operation.state;
  switch (release.type) {
    case "prompt":
      return promptForNewVersion(operation, commits);
    case "version":
      return operation.update({
        newVersion: new import_semver2.SemVer(release.version, true).version
      });
    default:
      return operation.update({
        release: release.type,
        newVersion: getNextVersion(currentVersion, release, commits)
      });
  }
}
function getNextVersion(currentVersion, bump, commits) {
  const oldSemVer = new import_semver2.SemVer(currentVersion);
  let type;
  if (bump.type === "next") {
    type = oldSemVer.prerelease.length ? "prerelease" : "patch";
  } else if (bump.type === "conventional") {
    type = oldSemVer.prerelease.length ? "prerelease" : determineSemverChange(commits);
  } else {
    type = bump.type;
  }
  const newSemVer = oldSemVer.inc(type, bump.preid);
  if (isPrerelease(bump.type) && newSemVer.prerelease.length === 2 && newSemVer.prerelease[0] === bump.preid && String(newSemVer.prerelease[1]) === "0") {
    newSemVer.prerelease[1] = "1";
    newSemVer.format();
  }
  return newSemVer.version;
}
function determineSemverChange(commits) {
  let [hasMajor, hasMinor] = [false, false];
  for (const commit of commits) {
    if (commit.isBreaking) {
      hasMajor = true;
    } else if (commit.type === "feat") {
      hasMinor = true;
    }
  }
  return hasMajor ? "major" : hasMinor ? "minor" : "patch";
}
function getNextVersions(currentVersion, preid, commits) {
  const next = {};
  const parse2 = import_semver2.default.parse(currentVersion);
  if (typeof parse2?.prerelease[0] === "string")
    preid = parse2?.prerelease[0] || "preid";
  for (const type of releaseTypes)
    next[type] = getNextVersion(currentVersion, { type, preid }, commits);
  return next;
}
async function promptForNewVersion(operation, commits) {
  const { currentVersion } = operation.state;
  const release = operation.options.release;
  const next = getNextVersions(currentVersion, release.preid, commits);
  const configCustomVersion = await operation.options.customVersion?.(currentVersion, import_semver2.default);
  const PADDING = 13;
  const answers = await (0, import_prompts.default)([
    {
      type: "autocomplete",
      name: "release",
      message: `Current version ${import_picocolors.default.green(currentVersion)}`,
      initial: configCustomVersion ? "config" : "next",
      choices: [
        { value: "major", title: `${"major".padStart(PADDING, " ")} ${import_picocolors.default.bold(next.major)}` },
        { value: "minor", title: `${"minor".padStart(PADDING, " ")} ${import_picocolors.default.bold(next.minor)}` },
        { value: "patch", title: `${"patch".padStart(PADDING, " ")} ${import_picocolors.default.bold(next.patch)}` },
        { value: "next", title: `${"next".padStart(PADDING, " ")} ${import_picocolors.default.bold(next.next)}` },
        { value: "conventional", title: `${"conventional".padStart(PADDING, " ")} ${import_picocolors.default.bold(next.conventional)}` },
        ...configCustomVersion ? [
          { value: "config", title: `${"from config".padStart(PADDING, " ")} ${import_picocolors.default.bold(configCustomVersion)}` }
        ] : [],
        { value: "prepatch", title: `${"pre-patch".padStart(PADDING, " ")} ${import_picocolors.default.bold(next.prepatch)}` },
        { value: "preminor", title: `${"pre-minor".padStart(PADDING, " ")} ${import_picocolors.default.bold(next.preminor)}` },
        { value: "premajor", title: `${"pre-major".padStart(PADDING, " ")} ${import_picocolors.default.bold(next.premajor)}` },
        { value: "none", title: `${"as-is".padStart(PADDING, " ")} ${import_picocolors.default.bold(currentVersion)}` },
        { value: "custom", title: "custom ...".padStart(PADDING + 4, " ") }
      ]
    },
    {
      type: (prev) => prev === "custom" ? "text" : null,
      name: "custom",
      message: "Enter the new version number:",
      initial: currentVersion,
      validate: (custom) => {
        return (0, import_semver2.valid)(custom) ? true : "That's not a valid version number";
      }
    }
  ]);
  const newVersion = answers.release === "none" ? currentVersion : answers.release === "custom" ? (0, import_semver2.clean)(answers.custom) : answers.release === "config" ? (0, import_semver2.clean)(configCustomVersion) : next[answers.release];
  if (!newVersion)
    import_node_process2.default.exit(1);
  switch (answers.release) {
    case "custom":
    case "config":
    case "next":
    case "conventional":
    case "none":
      return operation.update({ newVersion });
    default:
      return operation.update({ release: answers.release, newVersion });
  }
}

// src/git.ts
var import_tinyexec = require("tinyexec");
async function gitCommit(operation) {
  if (!operation.options.commit)
    return operation;
  const { all, noVerify, message } = operation.options.commit;
  const { updatedFiles, newVersion } = operation.state;
  let args = ["--allow-empty"];
  if (all) {
    args.push("--all");
  }
  if (noVerify) {
    args.push("--no-verify");
  }
  if (operation.options.sign) {
    args.push("--gpg-sign");
  }
  const commitMessage = formatVersionString(message, newVersion);
  args.push("--message", commitMessage);
  if (!all)
    args = args.concat(updatedFiles);
  await (0, import_tinyexec.x)("git", ["commit", ...args], { throwOnError: true });
  return operation.update({ event: "git commit" /* GitCommit */, commitMessage });
}
async function gitTag(operation) {
  if (!operation.options.tag)
    return operation;
  const { commit, tag } = operation.options;
  const { newVersion } = operation.state;
  const args = [
    // Create an annotated tag, which is recommended for releases.
    // See https://git-scm.com/docs/git-tag
    "--annotate",
    // Use the same commit message for the tag
    "--message",
    formatVersionString(commit.message, newVersion)
  ];
  const tagName = formatVersionString(tag.name, newVersion);
  args.push(tagName);
  if (operation.options.sign) {
    args.push("--sign");
  }
  await (0, import_tinyexec.x)("git", ["tag", ...args], { throwOnError: true });
  return operation.update({ event: "git tag" /* GitTag */, tagName });
}
async function gitPush(operation) {
  if (!operation.options.push)
    return operation;
  await (0, import_tinyexec.x)("git", ["push"], { throwOnError: true });
  if (operation.options.tag) {
    await (0, import_tinyexec.x)("git", ["push", "--tags"], { throwOnError: true });
  }
  return operation.update({ event: "git push" /* GitPush */ });
}
function formatVersionString(template, newVersion) {
  if (template.includes("%s"))
    return template.replace(/%s/g, newVersion);
  else
    return template + newVersion;
}

// src/normalize-options.ts
var import_node_fs2 = __toESM(require("fs"), 1);
var import_promises = __toESM(require("fs/promises"), 1);
var import_node_process3 = __toESM(require("process"), 1);
var import_js_yaml = __toESM(require("js-yaml"), 1);
var import_tinyglobby = require("tinyglobby");
async function normalizeOptions(raw) {
  const preid = typeof raw.preid === "string" ? raw.preid : "beta";
  const sign = Boolean(raw.sign);
  const push = Boolean(raw.push);
  const all = Boolean(raw.all);
  const install = Boolean(raw.install);
  const noVerify = Boolean(raw.noVerify);
  const cwd = raw.cwd || import_node_process3.default.cwd();
  const ignoreScripts = Boolean(raw.ignoreScripts);
  const execute = raw.execute;
  const recursive = Boolean(raw.recursive);
  let release;
  if (!raw.release || raw.release === "prompt")
    release = { type: "prompt", preid };
  else if (isReleaseType(raw.release) || raw.release === "next")
    release = { type: raw.release, preid };
  else
    release = { type: "version", version: raw.release };
  let tag;
  if (typeof raw.tag === "string")
    tag = { name: raw.tag };
  else if (raw.tag)
    tag = { name: "v" };
  let commit;
  if (typeof raw.commit === "string")
    commit = { all, noVerify, message: raw.commit };
  else if (raw.commit || tag || push)
    commit = { all, noVerify, message: "chore: release v" };
  if (recursive && !raw.files?.length) {
    raw.files = [
      "package.json",
      "package-lock.json",
      "packages/**/package.json",
      "jsr.json",
      "jsr.jsonc",
      "deno.json",
      "deno.jsonc"
    ];
    if (import_node_fs2.default.existsSync("pnpm-workspace.yaml")) {
      const pnpmWorkspace = await import_promises.default.readFile("pnpm-workspace.yaml", "utf8");
      const workspaces = import_js_yaml.default.load(pnpmWorkspace);
      const workspacesWithPackageJson = workspaces.packages.map((workspace) => `${workspace}/package.json`);
      const withoutExcludedWorkspaces = workspacesWithPackageJson.filter((workspace) => !workspace.startsWith("!") && !raw.files?.includes(workspace));
      raw.files = raw.files.concat(withoutExcludedWorkspaces);
    }
  } else {
    raw.files = raw.files?.length ? raw.files : ["package.json", "package-lock.json", "jsr.json", "jsr.jsonc", "deno.json", "deno.jsonc"];
  }
  const files = await (0, import_tinyglobby.glob)(
    raw.files,
    {
      cwd,
      onlyFiles: true,
      expandDirectories: false,
      ignore: [
        "**/{.git,node_modules,bower_components,__tests__,fixtures,fixture}/**"
      ]
    }
  );
  let ui;
  if (raw.interface === false) {
    ui = { input: false, output: false };
  } else if (raw.interface === true || !raw.interface) {
    ui = { input: import_node_process3.default.stdin, output: import_node_process3.default.stdout };
  } else {
    let { input, output, ...other } = raw.interface;
    if (input === true || input !== false && !input)
      input = import_node_process3.default.stdin;
    if (output === true || output !== false && !output)
      output = import_node_process3.default.stdout;
    ui = { input, output, ...other };
  }
  if (release.type === "prompt" && !(ui.input && ui.output))
    throw new Error("Cannot prompt for the version number because input or output has been disabled.");
  return {
    release,
    commit,
    tag,
    sign,
    push,
    files,
    cwd,
    install,
    interface: ui,
    ignoreScripts,
    execute,
    printCommits: raw.printCommits ?? true,
    customVersion: raw.customVersion,
    currentVersion: raw.currentVersion
  };
}

// src/operation.ts
var Operation = class _Operation {
  /**
   * The options for this operation.
   */
  options;
  /**
   * The current state of the operation.
   */
  state = {
    release: void 0,
    currentVersion: "",
    currentVersionSource: "",
    newVersion: "",
    commitMessage: "",
    tagName: "",
    updatedFiles: [],
    skippedFiles: []
  };
  /**
   * The results of the operation.
   */
  get results() {
    const options = this.options;
    const state = this.state;
    return {
      release: state.release,
      currentVersion: state.currentVersion,
      newVersion: state.newVersion,
      commit: options.commit ? state.commitMessage : false,
      tag: options.tag ? state.tagName : false,
      updatedFiles: state.updatedFiles.slice(),
      skippedFiles: state.skippedFiles.slice()
    };
  }
  /**
   * The callback that's used to report the progress of the operation.
   */
  _progress;
  /**
   * Private constructor.  Use the `Operation.start()` static method instead.
   */
  constructor(options, progress2) {
    this.options = options;
    this._progress = progress2;
    if (options.currentVersion) {
      this.update({
        currentVersion: options.currentVersion,
        currentVersionSource: "user"
      });
    }
  }
  /**
   * Starts a new `versionBump()` operation.
   */
  static async start(input) {
    const options = await normalizeOptions(input);
    return new _Operation(options, input.progress);
  }
  /**
   * Updates the operation state and results, and reports the updated progress to the user.
   */
  update({ event, script, ...newState }) {
    Object.assign(this.state, newState);
    if (event && this._progress) {
      this._progress({ event, script, ...this.results });
    }
    return this;
  }
};

// src/print-commits.ts
var import_picocolors2 = __toESM(require_picocolors(), 1);
var messageColorMap = {
  feat: import_picocolors2.default.green,
  feature: import_picocolors2.default.green,
  refactor: import_picocolors2.default.cyan,
  style: import_picocolors2.default.cyan,
  docs: import_picocolors2.default.blue,
  doc: import_picocolors2.default.blue,
  types: import_picocolors2.default.blue,
  type: import_picocolors2.default.blue,
  chore: import_picocolors2.default.gray,
  ci: import_picocolors2.default.gray,
  build: import_picocolors2.default.gray,
  deps: import_picocolors2.default.gray,
  dev: import_picocolors2.default.gray,
  fix: import_picocolors2.default.yellow,
  test: import_picocolors2.default.yellow,
  perf: import_picocolors2.default.magenta,
  revert: import_picocolors2.default.red,
  breaking: import_picocolors2.default.red
};
function formatParsedCommits(commits) {
  const typeLength = commits.map(({ type }) => type.length).reduce((a, b) => Math.max(a, b), 0);
  const scopeLength = commits.map(({ scope }) => scope.length).reduce((a, b) => Math.max(a, b), 0);
  return commits.map((commit) => {
    let color = messageColorMap[commit.type] || ((c5) => c5);
    if (commit.isBreaking) {
      color = (s) => import_picocolors2.default.inverse(import_picocolors2.default.red(s));
    }
    const paddedType = commit.type.padStart(typeLength + 1, " ");
    const paddedScope = !commit.scope ? " ".repeat(scopeLength ? scopeLength + 2 : 0) : import_picocolors2.default.dim("(") + commit.scope + import_picocolors2.default.dim(")") + " ".repeat(scopeLength - commit.scope.length);
    return [
      import_picocolors2.default.dim(commit.shortHash),
      " ",
      color === import_picocolors2.default.gray ? color(paddedType) : import_picocolors2.default.bold(color(paddedType)),
      " ",
      paddedScope,
      import_picocolors2.default.dim(":"),
      " ",
      color === import_picocolors2.default.gray ? color(commit.description) : commit.description
    ].join("");
  });
}
function printRecentCommits(commits) {
  if (!commits.length) {
    console.log();
    console.log(import_picocolors2.default.blue(`i`) + import_picocolors2.default.gray(` No commits since the last version`));
    console.log();
    return;
  }
  const prettified = formatParsedCommits(commits);
  console.log();
  console.log(
    import_picocolors2.default.bold(
      `${import_picocolors2.default.green(commits.length)} Commits since the last version:`
    )
  );
  console.log();
  console.log(prettified.join("\n"));
  console.log();
}

// src/run-npm-script.ts
var import_tinyexec2 = require("tinyexec");
async function runNpmScript(script, operation) {
  const { cwd, ignoreScripts } = operation.options;
  if (!ignoreScripts) {
    const { data: manifest } = await readJsoncFile("package.json", cwd);
    if (isManifest(manifest) && hasScript(manifest, script)) {
      await (0, import_tinyexec2.x)("npm", ["run", script, "--silent"], {
        nodeOptions: { stdio: "inherit" }
      });
      operation.update({ event: "npm script" /* NpmScript */, script });
    }
  }
  return operation;
}
function hasScript(manifest, script) {
  const scripts = manifest.scripts;
  if (scripts && typeof scripts === "object")
    return Boolean(scripts[script]);
  return false;
}

// src/update-files.ts
var import_node_fs3 = require("fs");
var path2 = __toESM(require("path"), 1);
async function updateFiles(operation) {
  const { files } = operation.options;
  for (const relPath of files) {
    const modified = await updateFile(relPath, operation);
    if (modified) {
      operation.update({
        event: "file updated" /* FileUpdated */,
        updatedFiles: operation.state.updatedFiles.concat(relPath)
      });
    } else {
      operation.update({
        event: "file skipped" /* FileSkipped */,
        skippedFiles: operation.state.skippedFiles.concat(relPath)
      });
    }
  }
  return operation;
}
async function updateFile(relPath, operation) {
  if (!(0, import_node_fs3.existsSync)(path2.join(operation.options.cwd, relPath))) {
    return false;
  }
  const name = path2.basename(relPath).trim().toLowerCase();
  switch (name) {
    case "package.json":
    case "package-lock.json":
    case "bower.json":
    case "component.json":
    case "jsr.json":
    case "jsr.jsonc":
    case "deno.json":
    case "deno.jsonc":
      return updateManifestFile(relPath, operation);
    default:
      return updateTextFile(relPath, operation);
  }
}
async function updateManifestFile(relPath, operation) {
  const { cwd } = operation.options;
  const { newVersion } = operation.state;
  let modified = false;
  const file = await readJsoncFile(relPath, cwd);
  if (!isManifest(file.data)) {
    return modified;
  }
  if (file.data.version == null) {
    return modified;
  }
  if (file.data.version !== newVersion) {
    file.modified.push([["version"], newVersion]);
    if (isPackageLockManifest(file.data))
      file.modified.push([["packages", "", "version"], newVersion]);
    await writeJsoncFile(file);
    modified = true;
  }
  return modified;
}
async function updateTextFile(relPath, operation) {
  const { cwd } = operation.options;
  const { currentVersion, newVersion } = operation.state;
  const modified = false;
  const file = await readTextFile(relPath, cwd);
  if (file.data.includes(currentVersion)) {
    const sanitizedVersion = currentVersion.replace(/(\W)/g, "\\$1");
    const replacePattern = new RegExp(`(\\b|v)${sanitizedVersion}\\b`, "g");
    file.data = file.data.replace(replacePattern, `$1${newVersion}`);
    await writeTextFile(file);
    return true;
  }
  return modified;
}

// src/version-bump.ts
async function versionBump(arg = {}) {
  if (typeof arg === "string")
    arg = { release: arg };
  const operation = await Operation.start(arg);
  const commits = (0, import_tiny_conventional_commits_parser.getRecentCommits)();
  if (operation.options.printCommits) {
    printRecentCommits(commits);
  }
  await getCurrentVersion(operation);
  await getNewVersion(operation, commits);
  if (arg.confirm) {
    printSummary(operation);
    if (!await (0, import_prompts2.default)({
      name: "yes",
      type: "confirm",
      message: "Bump?",
      initial: true
    }).then((r) => r.yes)) {
      import_node_process4.default.exit(1);
    }
  }
  await runNpmScript("preversion" /* PreVersion */, operation);
  await updateFiles(operation);
  if (operation.options.install) {
    const { detect } = await import("package-manager-detector/detect");
    const pm = await detect();
    if (!pm?.name) {
      throw new Error("Could not detect package manager, failed to run npm install");
    }
    const { COMMANDS, constructCommand } = await import("package-manager-detector/commands");
    const command = constructCommand(COMMANDS[pm.name].install, []);
    if (!command) {
      throw new Error("Could not find install command for package manager");
    }
    console.log(symbols_exports.info, "Installing dependencies with", `${command.command} ${command.args.join(" ")}`);
    await (0, import_tinyexec3.x)(command.command, command.args, {
      throwOnError: true,
      nodeOptions: {
        stdio: "inherit",
        cwd: operation.options.cwd
      }
    });
    console.log(symbols_exports.success, "Dependencies installed");
  }
  if (operation.options.execute) {
    if (typeof operation.options.execute === "function") {
      await operation.options.execute(operation);
    } else {
      const [command, ...args] = tokenizeArgs(operation.options.execute);
      console.log(symbols_exports.info, "Executing script", command, ...args);
      await (0, import_tinyexec3.x)(command, args, {
        throwOnError: true,
        nodeOptions: {
          stdio: "inherit",
          cwd: operation.options.cwd
        }
      });
      console.log(symbols_exports.success, "Script finished");
    }
  }
  await runNpmScript("version" /* Version */, operation);
  await gitCommit(operation);
  await gitTag(operation);
  await runNpmScript("postversion" /* PostVersion */, operation);
  await gitPush(operation);
  return operation.results;
}
function printSummary(operation) {
  console.log();
  console.log(`   files ${operation.options.files.map((i) => import_picocolors3.default.bold(i)).join("\n         ")}`);
  if (operation.options.commit)
    console.log(`  commit ${import_picocolors3.default.bold(formatVersionString(operation.options.commit.message, operation.state.newVersion))}`);
  if (operation.options.tag)
    console.log(`     tag ${import_picocolors3.default.bold(formatVersionString(operation.options.tag.name, operation.state.newVersion))}`);
  if (operation.options.execute)
    console.log(` execute ${import_picocolors3.default.bold(typeof operation.options.execute === "function" ? "function" : operation.options.execute)}`);
  if (operation.options.push)
    console.log(`    push ${import_picocolors3.default.cyan(import_picocolors3.default.bold("yes"))}`);
  if (operation.options.install)
    console.log(` install ${import_picocolors3.default.cyan(import_picocolors3.default.bold("yes"))}`);
  console.log();
  console.log(`    from ${import_picocolors3.default.bold(operation.state.currentVersion)}`);
  console.log(`      to ${import_picocolors3.default.green(import_picocolors3.default.bold(operation.state.newVersion))}`);
  console.log();
}

// src/cli/parse-args.ts
var import_node_process6 = __toESM(require("process"), 1);
var import_cac = __toESM(require("cac"), 1);
var import_picocolors4 = __toESM(require_picocolors(), 1);
var import_semver3 = require("semver");

// package.json
var version = "9.11.1";

// src/config.ts
var import_node_path2 = require("path");
var import_node_process5 = __toESM(require("process"), 1);
var import_c12 = require("c12");
var import_sync = __toESM(require("escalade/sync"), 1);
var bumpConfigDefaults = {
  commit: true,
  push: true,
  tag: true,
  sign: false,
  install: false,
  recursive: false,
  noVerify: false,
  confirm: true,
  ignoreScripts: false,
  all: false,
  noGitCheck: true,
  files: []
};
async function loadBumpConfig(overrides, cwd = import_node_process5.default.cwd()) {
  const name = "bump";
  const configFile = findConfigFile(name, cwd);
  const { config } = await (0, import_c12.loadConfig)({
    name,
    defaults: bumpConfigDefaults,
    overrides: {
      ...overrides
    },
    cwd: configFile ? (0, import_node_path2.dirname)(configFile) : cwd
  });
  return config;
}
function findConfigFile(name, cwd) {
  let foundRepositoryRoot = false;
  try {
    const candidates = ["js", "mjs", "ts", "mts", "json"].map((ext) => `${name}.config.${ext}`);
    return (0, import_sync.default)(cwd, (_dir, files) => {
      const match = files.find((file) => {
        if (candidates.includes(file))
          return true;
        if (file === ".git")
          foundRepositoryRoot = true;
        return false;
      });
      if (match)
        return match;
      if (foundRepositoryRoot) {
        throw null;
      }
      return false;
    });
  } catch (error2) {
    if (foundRepositoryRoot)
      return null;
    throw error2;
  }
}

// src/cli/parse-args.ts
async function parseArgs() {
  try {
    const { args, resultArgs } = loadCliArgs();
    const parsedArgs = {
      help: args.help,
      version: args.version,
      quiet: args.quiet,
      options: await loadBumpConfig({
        preid: args.preid,
        commit: args.commit,
        tag: args.tag,
        sign: args.sign,
        push: args.push,
        all: args.all,
        noGitCheck: args.noGitCheck,
        confirm: !args.yes,
        noVerify: !args.verify,
        install: args.install,
        files: [...args["--"] || [], ...resultArgs],
        ignoreScripts: args.ignoreScripts,
        currentVersion: args.currentVersion,
        execute: args.execute,
        printCommits: args.printCommits,
        recursive: args.recursive
      })
    };
    if (parsedArgs.options.files && parsedArgs.options.files.length > 0) {
      const firstArg = parsedArgs.options.files[0];
      if (firstArg === "prompt" || isReleaseType(firstArg) || (0, import_semver3.valid)(firstArg)) {
        parsedArgs.options.release = firstArg;
        parsedArgs.options.files.shift();
      }
    }
    if (parsedArgs.options.recursive && parsedArgs.options.files?.length)
      console.log(import_picocolors4.default.yellow("The --recursive option is ignored when files are specified"));
    return parsedArgs;
  } catch (error2) {
    return errorHandler(error2);
  }
}
function loadCliArgs(argv = import_node_process6.default.argv) {
  const cli = (0, import_cac.default)("bumpp");
  cli.version(version).usage("[...files]").option("--preid <preid>", "ID for prerelease").option("--all", `Include all files (default: ${bumpConfigDefaults.all})`).option("--no-git-check", `Skip git check`, { default: bumpConfigDefaults.noGitCheck }).option("-c, --commit [msg]", "Commit message", { default: true }).option("--no-commit", "Skip commit", { default: false }).option("-t, --tag [tag]", "Tag name", { default: true }).option("--no-tag", "Skip tag", { default: false }).option("--sign", "Sign commit and tag").option("--install", `Run 'npm install' after bumping version (default: ${bumpConfigDefaults.install})`, { default: false }).option("-p, --push", `Push to remote (default: ${bumpConfigDefaults.push})`).option("-y, --yes", `Skip confirmation (default: ${!bumpConfigDefaults.confirm})`).option("-r, --recursive", `Bump package.json files recursively (default: ${bumpConfigDefaults.recursive})`).option("--no-verify", "Skip git verification").option("--ignore-scripts", `Ignore scripts (default: ${bumpConfigDefaults.ignoreScripts})`).option("-q, --quiet", "Quiet mode").option("--current-version <version>", "Current version").option("--print-commits", "Print recent commits").option("-x, --execute <command>", "Commands to execute after version bumps").help();
  const result = cli.parse(argv);
  const rawArgs = cli.rawArgs;
  const args = result.options;
  const COMMIT_REG = /(?:-c|--commit|--no-commit)(?:=.*|$)/;
  const TAG_REG = /(?:-t|--tag|--no-tag)(?:=.*|$)/;
  const hasCommitFlag = rawArgs.some((arg) => COMMIT_REG.test(arg));
  const hasTagFlag = rawArgs.some((arg) => TAG_REG.test(arg));
  const { tag, commit, ...rest } = args;
  return {
    args: {
      ...rest,
      commit: hasCommitFlag ? commit : void 0,
      tag: hasTagFlag ? tag : void 0
    },
    resultArgs: result.args
  };
}
function errorHandler(error2) {
  console.error(error2.message);
  return import_node_process6.default.exit(9 /* InvalidArgument */);
}

// src/cli/index.ts
async function main() {
  try {
    import_node_process7.default.on("uncaughtException", errorHandler2);
    import_node_process7.default.on("unhandledRejection", errorHandler2);
    const { help, version: version2, quiet, options } = await parseArgs();
    if (help || version2) {
      import_node_process7.default.exit(0 /* Success */);
    } else {
      if (!options.all && !options.noGitCheck) {
        await checkGitStatus();
      }
      if (!quiet)
        options.progress = options.progress ? options.progress : progress;
      await versionBump(options);
    }
  } catch (error2) {
    errorHandler2(error2);
  }
}
async function checkGitStatus() {
  const { stdout } = await (0, import_tinyexec4.x)("git", ["status", "--porcelain"]);
  if (stdout.trim()) {
    throw new Error(`Git working tree is not clean:
${stdout}`);
  }
}
function progress({ event, script, updatedFiles, skippedFiles, newVersion }) {
  switch (event) {
    case "file updated" /* FileUpdated */:
      console.log(symbols_exports.success, `Updated ${updatedFiles.pop()} to ${newVersion}`);
      break;
    case "file skipped" /* FileSkipped */:
      console.log(symbols_exports.info, `${skippedFiles.pop()} did not need to be updated`);
      break;
    case "git commit" /* GitCommit */:
      console.log(symbols_exports.success, "Git commit");
      break;
    case "git tag" /* GitTag */:
      console.log(symbols_exports.success, "Git tag");
      break;
    case "git push" /* GitPush */:
      console.log(symbols_exports.success, "Git push");
      break;
    case "npm script" /* NpmScript */:
      console.log(symbols_exports.success, `Npm run ${script}`);
      break;
  }
}
function errorHandler2(error2) {
  let message = error2.message || String(error2);
  if (import_node_process7.default.env.DEBUG || import_node_process7.default.env.NODE_ENV === "development")
    message = error2.stack || message;
  console.error(message);
  import_node_process7.default.exit(1 /* FatalError */);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  checkGitStatus,
  main
});
